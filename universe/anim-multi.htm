<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Showroom - Sequential Animations</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
    }
    #info, #instructions, #loading {
      position: absolute;
      width: 100%;
      text-align: center;
      color: white;
      z-index: 10;
    }
    #info {
      top: 10px;
      background: rgba(0,0,0,0.5);
      padding: 5px;
    }
    #instructions {
      bottom: 20px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
    }
    #loading {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.7);
      padding: 20px;
      border-radius: 10px;
      font-size: 18px;
    }
    
    /* Mobile Controls - Hidden by default */
    #mobile-controls {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }
    
    #joystick-container {
      position: absolute;
      bottom: 100px;
      left: 20px;
      width: 120px;
      height: 120px;
      pointer-events: auto;
    }
    
    #joystick-base {
      width: 80px;
      height: 80px;
      background: rgba(255,255,255,0.2);
      border-radius: 50%;
      position: absolute;
      border: 2px solid rgba(255,255,255,0.5);
      top: 20px;
      left: 20px;
    }
    
    #joystick-handle {
      width: 40px;
      height: 40px;
      background: rgba(255,255,255,0.7);
      border-radius: 50%;
      position: absolute;
      top: 40px;
      left: 40px;
      transition: transform 0.1s;
    }
    
    #camera-control-area {
      position: absolute;
      top: 0;
      right: 0;
      width: 40%;
      height: 100%;
      pointer-events: auto;
    }
    
    #center-tap-area {
      position: absolute;
      top: 0;
      left: 40%;
      width: 20%;
      height: 100%;
      pointer-events: auto;
    }
    
    .control-hint {
      position: absolute;
      color: rgba(255,255,255,0.7);
      font-size: 12px;
      text-align: center;
      pointer-events: none;
    }
    
    #joystick-hint {
      bottom: 220px;
      left: 20px;
      width: 120px;
    }
    
    #camera-hint {
      top: 50%;
      right: 10%;
      transform: translateY(-50%);
    }
    
    #tap-hint {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <div id="info">3D Showroom | WASD: Move | Mouse: Look | R: Reset | ESC: Exit | SPACE: Next Animation</div>
  <div id="instructions">Character performing animations</div>
  <div id="loading">Loading model...</div>
  
  <!-- Mobile Controls - Only shown on mobile devices -->
  <div id="mobile-controls">
    <div id="joystick-container">
      <div id="joystick-base"></div>
      <div id="joystick-handle"></div>
      <div class="control-hint" id="joystick-hint">Move: Drag here</div>
    </div>
    <div id="camera-control-area">
      <div class="control-hint" id="camera-hint">Look: Drag here</div>
    </div>
    <div id="center-tap-area">
      <div class="control-hint" id="tap-hint">Tap for next animation</div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    let scene, camera, renderer, mixer, animatedModel, loader;
    const clock = new THREE.Clock();
    const EYE_HEIGHT = 1.7;

    // Define Mixamo models
    const MIXAMO_MODELS = ['girl.glb']; // Add other Mixamo models here as needed

    // Animation state variables
    let currentAction = null;
    let nextAction = null;
    let animationQueue = [];
    let currentAnimationIndex = 0;
    let animationClips = new Map();
    let isTransitioning = false;
    let currentModelName = '';
    const TRANSITION_DURATION = 0.5;

    // Detect if device is mobile/touch
    const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

    // Camera boundaries to ensure walls/floor are always visible
    const MOBILE_CAMERA_LIMITS = {
      minX: -15,  // Reduced from -20
      maxX: 15,   // Reduced from 20
      minZ: -15,  // Reduced from -20
      maxZ: 15    // Reduced from 20
    };

    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, EYE_HEIGHT, 5);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x202020);
      document.body.appendChild(renderer.domElement);

      // Show mobile controls only on mobile devices
      if (isMobile) {
        document.getElementById("mobile-controls").style.display = "block";
        document.getElementById("info").textContent = "3D Showroom | Drag left: Move | Drag right: Look | Tap center: Next Animation";
        document.body.style.touchAction = "none";
      }

      // --- Lighting: brighter & even ---
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);

      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
      dirLight.position.set(5, 10, 7.5);
      dirLight.castShadow = true;
      scene.add(dirLight);

      // --- Room setup ---
      const roomSize = 50;
      const wallHeight = 10;

      const floorMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.3 });
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), floorMat);
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      const wallMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.6 });
      const backWall = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, wallHeight), wallMat);
      backWall.position.set(0, wallHeight / 2, -roomSize / 2);
      scene.add(backWall);

      const leftWall = backWall.clone();
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(-roomSize / 2, wallHeight / 2, 0);
      scene.add(leftWall);

      const rightWall = backWall.clone();
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(roomSize / 2, wallHeight / 2, 0);
      scene.add(rightWall);

      const ceiling = new THREE.Mesh(
        new THREE.PlaneGeometry(roomSize, roomSize),
        new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.9 })
      );
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.y = wallHeight;
      scene.add(ceiling);

      // --- Create loader ---
      loader = new THREE.GLTFLoader();
      
      // --- Load model with multiple animations ---
      const animations = ['chacha', 'floss', 'crisscross'];
      loadModel("models/horror/teddy.glb", animations);

      setupControls();
      window.addEventListener("resize", onWindowResize);

      document.addEventListener("keydown", (e) => {
        if (e.code === "Escape") {
          window.location.href = "about:blank";
        }
      });
    }

    function loadModel(modelPath, animationArray = ['floss']) {
      loader.load(
        modelPath,
        (gltf) => {
          // CREATE CONTAINER
          const modelContainer = new THREE.Group();
          
          animatedModel = gltf.scene;
          
          // Add model to container
          modelContainer.add(animatedModel);
          
          // Scale the model
          animatedModel.scale.set(6, 6, 6);

          // ROTATE CONTAINER based on model type
          currentModelName = modelPath.split('/').pop();

          if (currentModelName.includes('witch') || currentModelName.includes('vamp') || currentModelName.includes('zombina') || currentModelName.includes('girl')) {
            // Witch/Vampire rotation
            modelContainer.rotation.set(
              THREE.MathUtils.degToRad(180),
              THREE.MathUtils.degToRad(-180), 
              THREE.MathUtils.degToRad(-180)
            );
          } else {
            // Default rotation for all other models
            modelContainer.rotation.set(
              THREE.MathUtils.degToRad(-100),
              THREE.MathUtils.degToRad(-180), 
              THREE.MathUtils.degToRad(-180)
            );
          }

          // Position the container
          modelContainer.position.set(0, 0, 0);

          // --- ALIGN MODEL FEET TO FLOOR ---
          const updatedBox = new THREE.Box3().setFromObject(modelContainer);
          const heightOffset = updatedBox.min.y;
          modelContainer.position.y = -heightOffset;

          // Add container to scene instead of model directly
          scene.add(modelContainer);

          // Create animation mixer for the model
          mixer = new THREE.AnimationMixer(animatedModel);

          // Set up animation queue and load all animations
          animationQueue = animationArray;
          loadAllAnimations(animationArray);

          document.getElementById("loading").style.display = "none";
          console.log(`&#9989; ${modelPath} loaded in container`);
        },
        (xhr) => {
          const fileName = modelPath.split('/').pop();
          document.getElementById("loading").textContent = `Loading ${fileName}... ${((xhr.loaded / xhr.total) * 100).toFixed(1)}%`;
        },
        (error) => {
          console.error(`&#10060; Error loading ${modelPath}:`, error);
          document.getElementById("loading").textContent = `Failed to load ${modelPath}`;
        }
      );
    }

    function loadAllAnimations(animationArray) {
      console.log(`&#128229; Loading ${animationArray.length} animations:`, animationArray);
      
      let loadedCount = 0;
      const totalAnimations = animationArray.length;

      animationArray.forEach(animName => {
        loadAnimationClip(animName).then(clip => {
          if (clip) {
            animationClips.set(animName, clip);
            loadedCount++;
            console.log(`&#9989; Loaded animation: ${animName} (${loadedCount}/${totalAnimations})`);
            
            // Start the sequence when all animations are loaded
            if (loadedCount === totalAnimations) {
              console.log(`&#127916; All animations loaded, starting sequence`);
              playNextAnimation();
            }
          }
        }).catch(error => {
          console.error(`&#10060; Failed to load ${animName}:`, error);
          loadedCount++;
          // Continue even if some animations fail
          if (loadedCount === totalAnimations && animationClips.size > 0) {
            playNextAnimation();
          }
        });
      });
    }

    function loadAnimationClip(animName) {
      return new Promise((resolve, reject) => {
        // Determine animation path based on model type
        const isMixamoModel = MIXAMO_MODELS.some(mixamoModel => currentModelName.includes(mixamoModel));
        const animationPath = isMixamoModel 
          ? `animations/mixamo/${animName}.json`
          : `animations/${animName}.json`;
        
        console.log(`&#128193; Loading animation from: ${animationPath}`);
        
        fetch(animationPath)
          .then(response => {
            if (!response.ok) {
              throw new Error(`Failed to load ${animName}.json`);
            }
            return response.json();
          })
          .then(animationData => {
            // Filter out problematic tracks
            const tracks = animationData.tracks.map(trackData => {
              // Remove ALL scale tracks
              if (trackData.name.includes('.scale')) {
                return null;
              }
              
              // Remove root bone rotations that cause flipping
              if (trackData.name.includes('.quaternion')) {
                const boneName = trackData.name.split('.')[0];
                if (boneName.includes('Char_01') || boneName === 'Bone') {
                  return null;
                }
              }
              
              return new THREE.KeyframeTrack(
                trackData.name,
                new Float32Array(trackData.times),
                new Float32Array(trackData.values)
              );
            }).filter(track => track !== null);

            const clip = new THREE.AnimationClip(
              animName,
              animationData.duration,
              tracks
            );
            
            resolve(clip);
          })
          .catch(error => {
            reject(error);
          });
      });
    }

    function playNextAnimation() {
      if (isTransitioning || animationQueue.length === 0) return;
      
      const animName = animationQueue[currentAnimationIndex];
      const clip = animationClips.get(animName);
      
      if (!clip) {
        console.warn(`&#9888;&#65039; Animation clip not found: ${animName}`);
        advanceToNextAnimation();
        return;
      }

      console.log(`&#127916; Playing animation: ${animName} (${currentAnimationIndex + 1}/${animationQueue.length})`);
      
      // Create new action
      nextAction = mixer.clipAction(clip);
      nextAction.setLoop(THREE.LoopRepeat, Infinity);
      nextAction.clampWhenFinished = false;
      
      // Crossfade from current to new animation
      if (currentAction) {
        isTransitioning = true;
        
        // Reset and start the new action
        nextAction.reset();
        nextAction.play();
        
        // Crossfade over TRANSITION_DURATION seconds
        currentAction.crossFadeTo(nextAction, TRANSITION_DURATION, false);
        
        // Update current action reference
        currentAction = nextAction;
        
        // Reset transitioning flag after transition
        setTimeout(() => {
          isTransitioning = false;
        }, TRANSITION_DURATION * 1000);
      } else {
        // First animation, no transition needed
        currentAction = nextAction;
        currentAction.play();
      }
      
      document.getElementById("instructions").innerHTML = 
        `Playing: ${animName} (${currentAnimationIndex + 1}/${animationQueue.length})`;
      
      // Auto-advance after animation duration (minus transition time)
      setTimeout(() => {
        advanceToNextAnimation();
      }, (clip.duration - TRANSITION_DURATION) * 1000);
    }

    function advanceToNextAnimation() {
      if (animationQueue.length === 0) return;
      
      currentAnimationIndex = (currentAnimationIndex + 1) % animationQueue.length;
      console.log(`&#9197;&#65039; Advancing to animation ${currentAnimationIndex + 1}: ${animationQueue[currentAnimationIndex]}`);
      playNextAnimation();
    }

    function setupControls() {
      const moveState = { forward: false, backward: false, left: false, right: false };
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      let yaw = 0;
      let isMouseDown = false;
      let previousMouseX = 0;

      // Different move speeds for mobile vs desktop
      const moveSpeed = isMobile ? 0.015 : 0.03; // Reduced by 50% for mobile
      const strafeSpeed = isMobile ? 0.008 : 0.03; // Significantly reduced for left/right on mobile

      // --- DESKTOP CONTROLS (Keep existing functionality) ---
      document.addEventListener("mousedown", (e) => {
        isMouseDown = true;
        previousMouseX = e.clientX;
      });
      document.addEventListener("mouseup", () => (isMouseDown = false));

      document.addEventListener("mousemove", (e) => {
        if (!isMouseDown) return;
        const deltaX = e.clientX - previousMouseX;
        previousMouseX = e.clientX;
        yaw -= deltaX * 0.002;
        camera.rotation.y = yaw;
      });

      document.addEventListener("keydown", (e) => {
        switch (e.code) {
          case "KeyS": moveState.forward = true; break;
          case "KeyW": moveState.backward = true; break;
          case "KeyD": moveState.left = true; break;
          case "KeyA": moveState.right = true; break;
          case "KeyR": resetCamera(); break;
          case "Space": 
            e.preventDefault();
            // Manual advance to next animation
            if (!isTransitioning) {
              advanceToNextAnimation();
            }
            break;
        }
      });
      document.addEventListener("keyup", (e) => {
        switch (e.code) {
          case "KeyS": moveState.forward = false; break;
          case "KeyW": moveState.backward = false; break;
          case "KeyD": moveState.left = false; break;
          case "KeyA": moveState.right = false; break;
        }
      });

      // --- MOBILE TOUCH CONTROLS (Only setup if mobile) ---
      if (isMobile) {
        let joystickActive = false;
        let cameraTouchActive = false;
        const joystickBase = document.getElementById('joystick-base');
        const joystickHandle = document.getElementById('joystick-handle');
        const joystickContainer = document.getElementById('joystick-container');
        const cameraControlArea = document.getElementById('camera-control-area');
        const centerTapArea = document.getElementById('center-tap-area');
        
        const joystickRect = joystickContainer.getBoundingClientRect();
        const joystickCenter = {
          x: joystickRect.left + joystickRect.width / 2,
          y: joystickRect.top + joystickRect.height / 2
        };
        const maxJoystickDistance = 35;

        // Touch start handler
        document.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          const touchX = touch.clientX;
          const screenWidth = window.innerWidth;
          
          // Determine which control area was touched
          if (touchX < screenWidth * 0.4) {
            // Left side - joystick control
            joystickActive = true;
            updateJoystick(touch);
          } else if (touchX > screenWidth * 0.6) {
            // Right side - camera control
            cameraTouchActive = true;
            previousMouseX = touchX;
          } else {
            // Center - tap for next animation
            if (!isTransitioning) {
              advanceToNextAnimation();
            }
          }
        });

        // Touch move handler
        document.addEventListener('touchmove', (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          const touchX = touch.clientX;
          
          if (joystickActive) {
            updateJoystick(touch);
          }
          
          if (cameraTouchActive) {
            const deltaX = touch.clientX - previousMouseX;
            previousMouseX = touch.clientX;
            yaw -= deltaX * 0.002;
            camera.rotation.y = yaw;
          }
        });

        // Touch end handler
        document.addEventListener('touchend', (e) => {
          joystickActive = false;
          cameraTouchActive = false;
          resetJoystick();
          // Reset all movement
          moveState.forward = moveState.backward = moveState.left = moveState.right = false;
        });

        function updateJoystick(touch) {
          const touchX = touch.clientX;
          const touchY = touch.clientY;
          
          const deltaX = touchX - joystickCenter.x;
          const deltaY = touchY - joystickCenter.y;
          
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          const angle = Math.atan2(deltaY, deltaX);
          
          const limitedDistance = Math.min(distance, maxJoystickDistance);
          
          // Update joystick handle position
          const handleX = limitedDistance * Math.cos(angle);
          const handleY = limitedDistance * Math.sin(angle);
          
          joystickHandle.style.transform = `translate(${handleX}px, ${handleY}px)`;
          
          // Update movement state based on joystick position
          const deadZone = 15; // Minimum distance to register movement
          
          if (limitedDistance > deadZone) {
            // Forward/backward based on Y axis (inverted)
            moveState.forward = deltaY < -deadZone;
            moveState.backward = deltaY > deadZone;
            
            // Left/right based on X axis
            moveState.left = deltaX < -deadZone;
            moveState.right = deltaX > deadZone;
          } else {
            moveState.forward = moveState.backward = moveState.left = moveState.right = false;
          }
        }

        function resetJoystick() {
          joystickHandle.style.transform = 'translate(0, 0)';
          moveState.forward = moveState.backward = moveState.left = moveState.right = false;
        }
      }

      function resetCamera() {
        camera.position.set(0, EYE_HEIGHT, 5);
        camera.rotation.set(0, 0, 0);
        yaw = 0;
        velocity.set(0, 0, 0);
      }

      camera.userData.update = function () {
        velocity.x -= velocity.x * 0.15;
        velocity.z -= velocity.z * 0.15;

        direction.z = Number(moveState.forward) - Number(moveState.backward);
        direction.x = Number(moveState.right) - Number(moveState.left);
        direction.normalize();

        // Apply different speeds for forward/backward vs left/right on mobile
        if (moveState.forward || moveState.backward) velocity.z -= direction.z * moveSpeed;
        if (moveState.left || moveState.right) velocity.x -= direction.x * (isMobile ? strafeSpeed : moveSpeed);

        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        forward.y = 0; right.y = 0;
        forward.normalize(); right.normalize();

        camera.position.add(forward.multiplyScalar(velocity.z));
        camera.position.add(right.multiplyScalar(velocity.x));
        camera.position.y = EYE_HEIGHT;

        // On mobile, enforce camera boundaries to keep walls/floor visible
        if (isMobile) {
          camera.position.x = THREE.MathUtils.clamp(
            camera.position.x, 
            MOBILE_CAMERA_LIMITS.minX, 
            MOBILE_CAMERA_LIMITS.maxX
          );
          camera.position.z = THREE.MathUtils.clamp(
            camera.position.z, 
            MOBILE_CAMERA_LIMITS.minZ, 
            MOBILE_CAMERA_LIMITS.maxZ
          );
        }
      };
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      if (camera.userData.update) camera.userData.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>