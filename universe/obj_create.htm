// Object creation functions for all booths with texture support

// Texture loader - will be initialized by hall.htm
let textureLoader = null;

// Initialize texture loader (call this from hall.htm after Three.js is loaded)
function initTextureLoader(loader) {
  textureLoader = loader;
}

// Create billboard at specified position with customizable height, display area, and texture
function createBillboard(x = 0, y = 0, z = 0, totalHeight = 2.2, displayWidth = 3.2, displayHeight = 1.2, texturePath = null, textureRepeats = {x: 1, y: 1}) {
  const billboardGroup = new THREE.Group();
  billboardGroup.name = 'billboard';

  const postHeight = totalHeight;
  const billboardDisplayHeight = displayHeight;
  const postSpacing = displayWidth + 0.4;

  // Post material
  const postMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

  // Billboard material - with texture if provided
  let billboardMaterial;
  if (texturePath && textureLoader) {
    const texture = textureLoader.load(texturePath);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(textureRepeats.x, textureRepeats.y);
    billboardMaterial = new THREE.MeshStandardMaterial({ 
      map: texture,
      roughness: 0.7
    });
  } else {
    billboardMaterial = new THREE.MeshStandardMaterial({ color: 0x2E86AB });
  }

  // Left post
  const leftPost = new THREE.Mesh(
    new THREE.CylinderGeometry(0.08, 0.08, postHeight, 16),
    postMaterial
  );
  leftPost.position.set(-postSpacing / 2, postHeight / 2, 0);

  // Right post
  const rightPost = leftPost.clone();
  rightPost.position.set(postSpacing / 2, postHeight / 2, 0);

  // Billboard frame
  const billboard = new THREE.Mesh(
    new THREE.BoxGeometry(displayWidth, billboardDisplayHeight, 0.1),
    billboardMaterial
  );
  billboard.position.set(0, postHeight - (billboardDisplayHeight / 2), 0.06);

  billboardGroup.add(leftPost, rightPost, billboard);
  billboardGroup.position.set(x, y, z);
  return billboardGroup;
}

// Create sign post with texture support
function createSignPost(x = 0, y = 0, z = 0, totalHeight = 1.8, displayWidth = 1.0, displayHeight = 0.5, texturePath = null, textureRepeats = {x: 1, y: 1}) {
  const signPostGroup = new THREE.Group();
  signPostGroup.name = 'signpost';

  const poleHeight = totalHeight;
  const signDisplayHeight = displayHeight;
  const signDisplayWidth = displayWidth;

  // Pole material
  const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });

  // Sign material - with texture if provided
  let signMaterial;
  if (texturePath && textureLoader) {
    const texture = textureLoader.load(texturePath);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(textureRepeats.x, textureRepeats.y);
    signMaterial = new THREE.MeshStandardMaterial({ 
      map: texture,
      roughness: 0.7
    });
  } else {
    signMaterial = new THREE.MeshStandardMaterial({ color: 0xF18F01 });
  }

  // Main pole
  const pole = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05, 0.05, poleHeight, 16),
    poleMaterial
  );
  pole.position.y = poleHeight / 2;

  // Rectangular sign
  const sign = new THREE.Mesh(
    new THREE.BoxGeometry(signDisplayWidth, signDisplayHeight, 0.03),
    signMaterial
  );
  sign.position.set(0, poleHeight - (signDisplayHeight / 2), 0.05);

  signPostGroup.add(pole, sign);
  signPostGroup.position.set(x, y, z);
  return signPostGroup;
}

// Create table with texture support
function createTable(x = 0, y = 0, z = 0, texturePath = null, textureRepeats = {x: 2, y: 1}) {
  const tableGroup = new THREE.Group();
  tableGroup.name = 'table';

  // Table material - with texture if provided
  let tableMaterial;
  if (texturePath && textureLoader) {
    const texture = textureLoader.load(texturePath);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(textureRepeats.x, textureRepeats.y);
    tableMaterial = new THREE.MeshStandardMaterial({ 
      map: texture,
      roughness: 0.8
    });
  } else {
    tableMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
  }

  // Leg material
  const legMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });

  // Table top
  const tableTop = new THREE.Mesh(
    new THREE.BoxGeometry(2, 0.05, 1),
    tableMaterial
  );
  tableTop.position.y = 0.8;

  // Table legs
  const legGeometry = new THREE.BoxGeometry(0.08, 0.8, 0.08);

  const leg1 = new THREE.Mesh(legGeometry, legMaterial);
  leg1.position.set(-0.9, 0.4, -0.4);

  const leg2 = new THREE.Mesh(legGeometry, legMaterial);
  leg2.position.set(0.9, 0.4, -0.4);

  const leg3 = new THREE.Mesh(legGeometry, legMaterial);
  leg3.position.set(-0.9, 0.4, 0.4);

  const leg4 = new THREE.Mesh(legGeometry, legMaterial);
  leg4.position.set(0.9, 0.4, 0.4);

  tableGroup.add(tableTop, leg1, leg2, leg3, leg4);
  tableGroup.position.set(x, y, z);
  return tableGroup;
}

// Create chair with texture support
function createChair(x = 0, y = 0, z = 0, rotationY = 0, texturePath = null, textureRepeats = {x: 2, y: 2}) {
  const chairGroup = new THREE.Group();
  chairGroup.name = 'chair';

  // Chair material - with texture if provided
  let chairMaterial;
  if (texturePath && textureLoader) {
    const texture = textureLoader.load(texturePath);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(textureRepeats.x, textureRepeats.y);
    chairMaterial = new THREE.MeshStandardMaterial({ 
      map: texture,
      roughness: 0.7
    });
  } else {
    chairMaterial = new THREE.MeshStandardMaterial({ color: 0x2E86AB });
  }

  // Leg material
  const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

  // Chair seat
  const seat = new THREE.Mesh(
    new THREE.BoxGeometry(0.6, 0.05, 0.6),
    chairMaterial
  );
  seat.position.y = 0.45;

  // Chair back
  const back = new THREE.Mesh(
    new THREE.BoxGeometry(0.6, 0.8, 0.05),
    chairMaterial
  );
  back.position.set(0, 0.85, -0.275);

  // Chair legs
  const legGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.45, 8);

  const leg1 = new THREE.Mesh(legGeometry, legMaterial);
  leg1.position.set(-0.25, 0.225, -0.25);

  const leg2 = new THREE.Mesh(legGeometry, legMaterial);
  leg2.position.set(0.25, 0.225, -0.25);

  const leg3 = new THREE.Mesh(legGeometry, legMaterial);
  leg3.position.set(-0.25, 0.225, 0.25);

  const leg4 = new THREE.Mesh(legGeometry, legMaterial);
  leg4.position.set(0.25, 0.225, 0.25);

  chairGroup.add(seat, back, leg1, leg2, leg3, leg4);
  chairGroup.position.set(x, y, z);
  chairGroup.rotation.y = rotationY;
  return chairGroup;
}

// Create cubicle with texture support
function createCubicle(x = 0, y = 0, z = 0, size = 6, wallTexturePath = null, bannerTexturePath = null, poleTexturePath = null, floorTexturePath = null) {
  console.log('&#128260; createCubicle called with:');
  console.log('  - wallTexturePath:', wallTexturePath);
  console.log('  - bannerTexturePath:', bannerTexturePath); 
  console.log('  - poleTexturePath:', poleTexturePath);
  console.log('  - floorTexturePath:', floorTexturePath);
  
  const cubicleGroup = new THREE.Group();
  cubicleGroup.name = 'cubicle';

  const halfSize = size / 2;
  const poleHeight = 2.5;
  const wallHeight = poleHeight;
  const poleRadius = 0.08;

  // Wall material - with texture if provided
  let wallMaterial;
  if (wallTexturePath && textureLoader) {
    const texture = textureLoader.load(wallTexturePath, 
      function loaded() { console.log('&#9989; Wall texture loaded:', wallTexturePath); },
      function progress() { },
      function error(err) { console.error('&#10060; Failed to load wall texture:', wallTexturePath, err); }
    );
    // No repeating for single images
    wallMaterial = new THREE.MeshStandardMaterial({ 
      map: texture,
      roughness: 0.8
    });
  } else {
    console.log('&#9888;&#65039; Using fallback wall material for path:', wallTexturePath);
    wallMaterial = new THREE.MeshStandardMaterial({ color: 0x2E86AB });
  }

  // Banner material - with texture if provided
  let bannerMaterial;
  if (bannerTexturePath && textureLoader) {
    const texture = textureLoader.load(bannerTexturePath, 
      function loaded() { console.log('&#9989; Banner texture loaded:', bannerTexturePath); },
      function progress() { },
      function error(err) { console.error('&#10060; Failed to load banner texture:', bannerTexturePath, err); }
    );
    // No repeating for single images
    bannerMaterial = new THREE.MeshStandardMaterial({ 
      map: texture,
      emissive: 0x333333,
      emissiveIntensity: 0.1
    });
  } else {
    console.log('&#9888;&#65039; Using fallback banner material for path:', bannerTexturePath);
    bannerMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x2E86AB,
      emissive: 0x2E86AB,
      emissiveIntensity: 0.2
    });
  }

  // Pole material - with texture if provided
  let poleMaterial;
  if (poleTexturePath && textureLoader) {
    const texture = textureLoader.load(poleTexturePath, 
      function loaded() { console.log('&#9989; Pole texture loaded:', poleTexturePath); },
      function progress() { },
      function error(err) { console.error('&#10060; Failed to load pole texture:', poleTexturePath, err); }
    );
    // No repeating for single images
    poleMaterial = new THREE.MeshStandardMaterial({ 
      map: texture,
      roughness: 0.7
    });
  } else {
    console.log('&#9888;&#65039; Using fallback pole material for path:', poleTexturePath);
    poleMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
  }

  // Floor material - with texture if provided
  let floorMaterial;
  if (floorTexturePath && textureLoader) {
    const texture = textureLoader.load(floorTexturePath, 
      function loaded() { console.log('&#9989; Floor texture loaded:', floorTexturePath); },
      function progress() { },
      function error(err) { console.error('&#10060; Failed to load floor texture:', floorTexturePath, err); }
    );
    // No repeating for single images
    floorMaterial = new THREE.MeshStandardMaterial({ 
    map: texture,
    roughness: 0.9,
    metalness: 0.0
      
    });
  } else {
    console.log('&#9888;&#65039; Using fallback floor material for path:', floorTexturePath);
    floorMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x666666, 
    roughness: 0.9,
    metalness: 0.0
      
    });
  }

  // Rope material
  const ropeMaterial = new THREE.MeshStandardMaterial({ color: 0xCCCCCC });

  // Horizontal bar material
  const barMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

  // Create 4 corner poles
  const poleGeometry = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight, 16);

  const backLeftPole = new THREE.Mesh(poleGeometry, poleMaterial);
  backLeftPole.position.set(-halfSize, poleHeight / 2, -halfSize);

  const backRightPole = new THREE.Mesh(poleGeometry, poleMaterial);
  backRightPole.position.set(halfSize, poleHeight / 2, -halfSize);

  const frontLeftPole = new THREE.Mesh(poleGeometry, poleMaterial);
  frontLeftPole.position.set(-halfSize, poleHeight / 2, halfSize);

  const frontRightPole = new THREE.Mesh(poleGeometry, poleMaterial);
  frontRightPole.position.set(halfSize, poleHeight / 2, halfSize);

  // Create back wall
  const wallGeometry = new THREE.BoxGeometry(size, wallHeight, 0.1);
  const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
  backWall.position.set(0, wallHeight / 2, -halfSize);

  // Create booth floor
  const floorGeometry = new THREE.PlaneGeometry(size, size);
  const boothFloor = new THREE.Mesh(floorGeometry, floorMaterial);
  boothFloor.rotation.x = -Math.PI / 2;
  boothFloor.position.y = 0.01;

  // Create horizontal bar across front poles
  const barGeometry = new THREE.CylinderGeometry(0.03, 0.03, size, 8);
  const horizontalBar = new THREE.Mesh(barGeometry, barMaterial);
  horizontalBar.position.set(0, poleHeight - 0.15, halfSize);
  horizontalBar.rotation.z = Math.PI / 2;

  // Create front header/banner - HALF WIDTH
  const bannerWidth = size * 0.5; // Half the cubicle width
  const bannerHeight = 0.6;
  const bannerGeometry = new THREE.BoxGeometry(bannerWidth, bannerHeight, 0.05);
  const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);
  banner.position.set(0, poleHeight - bannerHeight/2, halfSize + 0.03);

  // Create banner support ropes
  const ropeGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.2, 8);
  
  const leftRope = new THREE.Mesh(ropeGeometry, ropeMaterial);
  leftRope.position.set(-bannerWidth/2, poleHeight - 0.1, halfSize);
  leftRope.rotation.z = Math.PI / 6;
  
  const rightRope = new THREE.Mesh(ropeGeometry, ropeMaterial);
  rightRope.position.set(bannerWidth/2, poleHeight - 0.1, halfSize);
  rightRope.rotation.z = -Math.PI / 6;

  // Add all components to cubicle group
  cubicleGroup.add(
    backLeftPole, backRightPole, frontLeftPole, frontRightPole,
    backWall, boothFloor, horizontalBar, banner, leftRope, rightRope
  );

  cubicleGroup.position.set(x, y, z);
  return cubicleGroup;
}

// Create simple display stand with texture support
function createDisplayStand(x = 0, y = 0, z = 0, texturePath = null, textureRepeats = {x: 1, y: 1}) {
  const standGroup = new THREE.Group();
  standGroup.name = 'display-stand';

  // Platform material - with texture if provided
  let platformMaterial;
  if (texturePath && textureLoader) {
    const texture = textureLoader.load(texturePath);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(textureRepeats.x, textureRepeats.y);
    platformMaterial = new THREE.MeshStandardMaterial({ 
      map: texture,
      roughness: 0.6
    });
  } else {
    platformMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
  }

  // Base and pole materials
  const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });

  // Stand base
  const base = new THREE.Mesh(
    new THREE.CylinderGeometry(0.4, 0.3, 0.1, 16),
    baseMaterial
  );
  base.position.y = 0.05;

  // Stand pole
  const pole = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05, 0.05, 1.2, 16),
    poleMaterial
  );
  pole.position.y = 0.7;

  // Display platform
  const platform = new THREE.Mesh(
    new THREE.CylinderGeometry(0.5, 0.5, 0.05, 16),
    platformMaterial
  );
  platform.position.y = 1.3;

  standGroup.add(base, pole, platform);
  standGroup.position.set(x, y, z);
  return standGroup;
}

// Create light fixture (standard height)
function createLightFixture(x = 0, y = 0, z = 0) {
  const lightGroup = new THREE.Group();
  lightGroup.name = 'light-fixture';

  // Light pole
  const pole = new THREE.Mesh(
    new THREE.CylinderGeometry(0.03, 0.03, 2.5, 8),
    new THREE.MeshStandardMaterial({ color: 0xCCCCCC })
  );
  pole.position.y = 1.25;

  // Light fixture
  const fixture = new THREE.Mesh(
    new THREE.BoxGeometry(0.3, 0.1, 0.3),
    new THREE.MeshStandardMaterial({ 
      color: 0xFFFFAA, 
      emissive: 0xFFFFAA, 
      emissiveIntensity: 0.3 
    })
  );
  fixture.position.set(0, 2.4, 0);

  lightGroup.add(pole, fixture);
  lightGroup.position.set(x, y, z);
  return lightGroup;
}

// Create floor area with texture support
function createFloorArea(x = 0, y = 0, z = 0, width = 10, depth = 10, texturePath = null, textureRepeats = {x: 2, y: 2}) {
  const floorGroup = new THREE.Group();
  floorGroup.name = 'floor-area';

  // Floor material - with texture if provided
  let floorMaterial;
  if (texturePath && textureLoader) {
    const texture = textureLoader.load(texturePath);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(textureRepeats.x, textureRepeats.y);
    floorMaterial = new THREE.MeshStandardMaterial({ 
      map: texture,
      roughness: 0.9
    });
  } else {
    floorMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x666666, 
      roughness: 0.8 
    });
  }

  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(width, depth),
    floorMaterial
  );
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = y;

  floorGroup.add(floor);
  floorGroup.position.set(x, y, z);
  return floorGroup;
}

// Export the init function
window.initObjectTextures = initTextureLoader;

// Export all creation functions to global scope
window.ObjectCreator = {
  createBillboard,
  createSignPost,
  createTable,
  createChair,
  createCubicle,
  createDisplayStand,
  createLightFixture,
  createFloorArea,
  initTextureLoader
};