<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My 3D Product Showroom</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #000;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            padding: 5px;
            background: rgba(0,0,0,0.5);
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="info">My 3D Product Showroom | Products: 4 | Use WASD to move, Q/E to go up/down</div>
    <div id="instructions">WASD: Move | Q/E: Up/Down | Mouse: Look around | Click products for info | R: Reset position</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Basic Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x222222);
        document.body.appendChild(renderer.domElement);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        // Create a simple showroom floor
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x444444, 
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

// Create a professional showroom with different wall treatments
const roomSize = 20;
const wallHeight = 10;

// Floor (already exists, but let's make it nicer)
floor.material.color.set(0x333333);
floor.material.roughness = 0.3;

// Add a more detailed floor texture
const floorTexture = new THREE.MeshStandardMaterial({ 
    color: 0x1a1a1a, 
    roughness: 0.2,
    metalness: 0.1
});
floor.material = floorTexture;

// Back wall - Feature wall
const backWall = new THREE.Mesh(
    new THREE.PlaneGeometry(roomSize, wallHeight),
    new THREE.MeshStandardMaterial({ 
        color: 0x2c3e50,  // Dark blue-gray
        roughness: 0.6
    })
);
backWall.position.set(0, wallHeight/2, -roomSize/2);
scene.add(backWall);

// Add company logo or text to back wall
const logoGeometry = new THREE.PlaneGeometry(6, 2);
const logoMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xe74c3c,  // Red accent
    roughness: 0.3
});
const logo = new THREE.Mesh(logoGeometry, logoMaterial);
logo.position.set(0, wallHeight - 2, -roomSize/2 + 0.1);
backWall.add(logo);

// Side walls - lighter color
const sideWallMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xecf0f1,  // Light gray
    roughness: 0.7
});

// Left wall with display shelves
const leftWall = new THREE.Mesh(
    new THREE.PlaneGeometry(roomSize, wallHeight),
    sideWallMaterial
);
leftWall.position.set(-roomSize/2, wallHeight/2, 0);
leftWall.rotation.y = Math.PI / 2;
scene.add(leftWall);

// Right wall with windows (conceptual)
const rightWall = new THREE.Mesh(
    new THREE.PlaneGeometry(roomSize, wallHeight),
    sideWallMaterial
);
rightWall.position.set(roomSize/2, wallHeight/2, 0);
rightWall.rotation.y = -Math.PI / 2;
scene.add(rightWall);

// Ceiling with lighting panels
const ceiling = new THREE.Mesh(
    new THREE.PlaneGeometry(roomSize, roomSize),
    new THREE.MeshStandardMaterial({ 
        color: 0x34495e,  // Dark gray
        roughness: 0.9,
        metalness: 0.1
    })
);
ceiling.position.set(0, wallHeight, 0);
ceiling.rotation.x = Math.PI / 2;
scene.add(ceiling);

// Add ceiling lights
const lightGeometry = new THREE.PlaneGeometry(2, 2);
const lightMaterial = new THREE.MeshBasicMaterial({ 
    color: 0xffffcc,  // Warm light color
    transparent: true,
    opacity: 0.8
});

// Create multiple ceiling lights
const lightPositions = [
    [-5, 0], [0, 0], [5, 0],
    [-5, -5], [0, -5], [5, -5],
    [-5, 5], [0, 5], [5, 5]
];

lightPositions.forEach(pos => {
    const lightPanel = new THREE.Mesh(lightGeometry, lightMaterial);
    lightPanel.position.set(pos[0], wallHeight - 0.1, pos[1]);
    lightPanel.rotation.x = -Math.PI / 2;
    scene.add(lightPanel);
    
    // Add actual light sources
    const pointLight = new THREE.PointLight(0xffffcc, 0.3, 10);
    pointLight.position.set(pos[0], wallHeight - 2, pos[1]);
    scene.add(pointLight);
});
        // Add grid helper to see the space better
        const gridHelper = new THREE.GridHelper(20, 20, 0x000000, 0x000000);
        gridHelper.material.opacity = 0.2;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        // Create sample products (colored boxes for demonstration)
        const products = [];
        const productInfo = [
            { name: "Smartphone", color: 0x3498db, price: "$999", x: -4, z: -4 },
            { name: "Laptop", color: 0xe74c3c, price: "$1299", x: 4, z: -4 },
            { name: "Headphones", color: 0x2ecc71, price: "$299", x: -4, z: 4 },
            { name: "Smart Watch", color: 0xf1c40f, price: "$399", x: 4, z: 4 }
        ];

        productInfo.forEach(info => {
            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const material = new THREE.MeshStandardMaterial({ 
                color: info.color,
                roughness: 0.3,
                metalness: 0.7
            });
            const product = new THREE.Mesh(geometry, material);
            product.position.set(info.x, 0.75, info.z);
            product.userData = info; // Store product info
            
            scene.add(product);
            products.push(product);
        });

        // Camera position
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        // Simple first-person controls variables
        const moveState = { 
            forward: false, 
            backward: false, 
            left: false, 
            right: false,
            up: false,
            down: false
        };
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveSpeed = 0.1;

        // Mouse look variables
        let isMouseDown = false;
        let previousMouseX = 0;
        let yaw = 0;
        let pitch = 0;

        // Mouse event listeners
        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            previousMouseX = event.clientX;
            
            // Raycasting for product clicks
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(products);
            if (intersects.length > 0) {
                const product = intersects[0].object;
                const info = product.userData;
                alert(`Product: ${info.name}\nPrice: ${info.price}\n\nMore details coming soon!`);
            }
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        document.addEventListener('mousemove', (event) => {
            if (!isMouseDown) return;

            const deltaX = event.clientX - previousMouseX;
            previousMouseX = event.clientX;

            yaw -= deltaX * 0.01;
            
            // Update camera rotation
            camera.rotation.y = yaw;
        });

        // Keyboard controls - CORRECTED VERSION
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'KeyQ': moveState.up = true; break;      // Q to go UP
                case 'KeyE': moveState.down = true; break;    // E to go DOWN
                case 'KeyR': resetCamera(); break;            // R to reset position
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyD': moveState.right = false; break;
                case 'KeyQ': moveState.up = false; break;
                case 'KeyE': moveState.down = false; break;
            }
        });

        // Reset camera position function
function resetCamera() {
    camera.position.set(0, 5, 10);
    camera.rotation.set(0, 0, 0);
    yaw = 0;
    pitch = 0;
    velocity.set(0, 0, 0);
}
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Movement - CORRECTED VERSION
            velocity.x -= velocity.x * 0.08;
            velocity.z -= velocity.z * 0.08;
            velocity.y -= velocity.y * 0.08; // Add Y axis damping

            direction.z = Number(moveState.forward) - Number(moveState.backward);
            direction.x = Number(moveState.right) - Number(moveState.left);
            direction.y = Number(moveState.up) - Number(moveState.down); // Vertical movement
            direction.normalize();

            if (moveState.forward || moveState.backward) velocity.z -= direction.z * moveSpeed;
            if (moveState.left || moveState.right) velocity.x -= direction.x * moveSpeed;
            if (moveState.up || moveState.down) velocity.y -= direction.y * moveSpeed; // Apply vertical movement

            // Apply movement relative to camera direction (horizontal only)
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

            camera.position.add(forward.multiplyScalar(velocity.z));
            camera.position.add(right.multiplyScalar(velocity.x));
            camera.position.y += velocity.y; // Apply vertical movement directly

            // Keep camera within reasonable bounds (optional)
            camera.position.x = THREE.MathUtils.clamp(camera.position.x, -15, 15);
            camera.position.z = THREE.MathUtils.clamp(camera.position.z, -15, 15);
            camera.position.y = THREE.MathUtils.clamp(camera.position.y, 1, 20); // Limit height

            renderer.render(scene, camera);
        }

        // Start the animation
        animate();
    </script>
</body>
</html>