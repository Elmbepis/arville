<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ARVille Web AR for Everyone!!!</title>

    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
      body { margin: 0; overflow: hidden; }
      #ar-scene { position: fixed; top:0; left:0; width:100%; height:100%; }
      #start-button {
        position: fixed; top:50%; left:50%;
        transform: translate(-50%,-50%);
        padding: 12px 22px; font-size:18px; z-index:1000;
        background:#007bff; color:white; border:none; border-radius:8px; cursor:pointer;
      }
    </style>
  </head>

  <body>
    <button id="start-button">Start AR Experience</button>

    <a-scene
      id="ar-scene"
      embedded
      arjs="debugUIEnabled: false; sourceType: webcam; patternRatio: 0.9;"
      style="display: none;"
    >
      <!-- Ambient Light for overall scene brightness -->
      <a-entity light="type: ambient; color: #888; intensity: 1"></a-entity>

      <!-- Directional Light for front illumination -->
      <a-entity light="type: directional; color: #FFFFFF; intensity: 1.5; position: 0 3 3" shadow></a-entity>

      <!-- Point Light for additional front fill -->
      <a-entity light="type: point; color: #FFFFFF; intensity: 1.5; position: 0 2 2"></a-entity>

      <!-- Markers will be generated automatically by JavaScript -->
      <a-entity camera></a-entity>
    </a-scene>

    <script>
      (function () {
        // ==================== SINGLE SOURCE OF TRUTH ====================
        const markerDefinitions = [
          { id: 'girl',       scale: '2 2 2',     position: '0 -0.4 0' },
          { id: 'boy',        scale: '0.7 0.5 0.7', position: '0 -0.4 0' },
          { id: 'maria',      scale: '0.4 0.4 0.4',   position: '0 -0.4 0' },
          { id: 'frankie',    scale: '0.3 0.15 0.3', position: '0 -0.5 0' },
          { id: 'devil',      scale: '2 2 2',     position: '0 -0.4 0' },
          { id: 'bones',      scale: '2 2 2',     position: '0 -0.4 0' },
          { id: 'scarecrow',  scale: '2 2 2',     position: '0 -0.4 0' },
          { id: 'clown',      scale: '2 2 2',     position: '0 -0.4 0' },
          { id: 'pumpkin',    scale: '2 2 2',     position: '0 -0.4 0' },
          { id: 'witch',      scale: '2 2 2',     position: '0 -0.4 0' },
          { id: 'zombina',    scale: '2 2 2',     position: '0 -0.4 0' },
          { id: 'wolfie',     scale: '2 2 2',     position: '0 -0.4 0' }
        ];

        // ==================== CACHE MANAGER ====================
        class ARModelCache {
            constructor() {
                this.cache = new Map();
                this.loading = new Map();
            }
            
            async loadModel(url) {
                if (this.cache.has(url)) {
                    console.log('&#9989; Using cached model:', url);
                    return this.cache.get(url);
                }
                
                if (this.loading.has(url)) {
                    return this.loading.get(url);
                }
                
                console.log('&#128229; Downloading model:', url);
                const promise = fetch(url)
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        return response.arrayBuffer();
                    })
                    .then(data => {
                        this.cache.set(url, data);
                        this.loading.delete(url);
                        return data;
                    })
                    .catch(error => {
                        this.loading.delete(url);
                        console.error('&#10060; Failed to load model:', url, error);
                        throw error;
                    });
                    
                this.loading.set(url, promise);
                return promise;
            }
        }

        // Initialize cache
        const modelCache = new ARModelCache();

        const startButton = document.getElementById("start-button");
        const arScene = document.getElementById("ar-scene");

        // Variables for animation and sound management
        const mixers = {};
        const clocks = {};
        const rafIds = {};
        const mixerActiveStates = {};
        const animationStates = {};
        const soundTimeouts = {};
        const soundWasBrieflyLost = {};

        // Orientation detection
        let currentOrientation = 'unknown';
        let arInitialized = false;

        // ==================== AUTOMATED MARKER GENERATION ====================
        function generateMarkers() {
          markerDefinitions.forEach(marker => {
            const basePath = 'AR/patts/mixamo';
            const markerHTML = `
              <a-marker type="pattern" url="${basePath}/${marker.id}.patt" id="marker-${marker.id}">
                <a-entity id="${marker.id}-container" position="0 0.6 0" rotation="0 0 0">
                  <a-entity
                    id="${marker.id}-wrapper"
                    position="0 0 0"
                    rotation="-90 0 0"
                    class="orientation-dependent"
                  >
                    <a-entity
                      id="${marker.id}-model"
                      gltf-model="AR/models/mixamo/${marker.id}.glb"
                      scale="${marker.scale}"
                      position="${marker.position}"
                    ></a-entity>
                  </a-entity>
                </a-entity>
                <a-entity
                  id="${marker.id}-sound"
                  sound="src: AR/sounds/mixamo/${marker.id}.mp3; autoplay: false; loop: true; volume: 4; preload: auto"
                ></a-entity>
              </a-marker>
            `;
            document.querySelector('a-scene').insertAdjacentHTML('beforeend', markerHTML);
          });
        }

        // ==================== AUTOMATED MARKER SETUP ====================
        function setupMarkers() {
          return markerDefinitions.map(marker => ({
            id: marker.id,
            modelId: `${marker.id}-model`,
            wrapperId: `${marker.id}-wrapper`,
            soundId: `${marker.id}-sound`,
            containerId: `${marker.id}-container`
          }));
        }

        // Generate markers immediately
        generateMarkers();
        const markers = setupMarkers();

        // ==================== MARKER EVENT HANDLING ====================
        function initializeMarkerEvents() {
          markers.forEach(markerConfig => {
            const marker = document.querySelector(`#marker-${markerConfig.id}`);
            const model = document.querySelector(`#${markerConfig.modelId}`);
            const wrapper = document.querySelector(`#${markerConfig.wrapperId}`);
            const soundEl = document.querySelector(`#${markerConfig.soundId}`);

            // Initialize states
            animationStates[markerConfig.modelId] = {
              clips: [],
              currentClipIndex: 0,
              currentAction: null,
              nextAction: null,
              isTransitioning: false,
              transitionDuration: 0.5
            };

            soundWasBrieflyLost[markerConfig.soundId] = false;

            // Marker event handlers
            marker.addEventListener("markerFound", () => {
              if (soundTimeouts[markerConfig.id]) {
                clearTimeout(soundTimeouts[markerConfig.id]);
                soundTimeouts[markerConfig.id] = null;
                soundWasBrieflyLost[markerConfig.soundId] = true;
              }
              
              if (mixers[markerConfig.modelId]) {
                mixerActiveStates[markerConfig.modelId] = true;
              }
              
              playMarkerSound(markerConfig.soundId);
            });

            marker.addEventListener("markerLost", () => {
              if (mixers[markerConfig.modelId]) {
                mixerActiveStates[markerConfig.modelId] = false;
              }
              
              soundWasBrieflyLost[markerConfig.soundId] = false;
              
              soundTimeouts[markerConfig.id] = setTimeout(() => {
                stopMarkerSound(markerConfig.soundId);
                soundTimeouts[markerConfig.id] = null;
              }, 1000);
            });

            // Model loaded event
            model.addEventListener("model-loaded", (e) => {
              setupModelAnimations(markerConfig.modelId, e.detail.model);
            });

            // Cache interception
            const originalSetAttribute = model.setAttribute.bind(model);
            model.setAttribute = function(attr, value) {
              if (attr === 'gltf-model' && value && !value.startsWith('blob:')) {
                modelCache.loadModel(value)
                  .then(data => {
                    const blob = new Blob([data]);
                    const objectUrl = URL.createObjectURL(blob);
                    originalSetAttribute('gltf-model', objectUrl);
                    
                    model.addEventListener('model-loaded', () => {
                      setTimeout(() => URL.revokeObjectURL(objectUrl), 1000);
                    });
                  })
                  .catch(error => {
                    console.error('Cache load failed, falling back to original:', error);
                    originalSetAttribute('gltf-model', value);
                  });
              } else {
                originalSetAttribute(attr, value);
              }
            };

            // Store for orientation updates
            marker.wrapper = wrapper;
          });
        }

        // ==================== APPLICATION INITIALIZATION ====================
        startButton.addEventListener("click", () => {
          startButton.style.display = "none";
          arScene.style.display = "block";
          arInitialized = true;
          updateAllModelDimensions();
        });

        // Initialize all marker events after DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initializeMarkerEvents);
        } else {
          initializeMarkerEvents();
        }

        // ==================== UTILITY FUNCTIONS ====================
        function detectOrientation() {
          if (typeof window.orientation !== 'undefined') {
            currentOrientation = Math.abs(window.orientation) === 90 ? 'landscape' : 'portrait';
          } else if (window.screen?.orientation?.type) {
            currentOrientation = window.screen.orientation.type.includes('landscape') ? 'landscape' : 'portrait';
          } else {
            currentOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
          }
          
          if (arInitialized) updateAllModelDimensions();
          return currentOrientation;
        }

        function updateAllModelDimensions() {
          markers.forEach(markerConfig => {
            const wrapper = document.querySelector(`#${markerConfig.wrapperId}`);
            if (wrapper) updateModelDimensions(wrapper);
          });
        }

        function updateModelDimensions(wrapper) {
          if (!wrapper) return;
          const scaleValue = currentOrientation === 'portrait' ? '2 0.8 2' : '1 1.8 1';
          wrapper.setAttribute('scale', scaleValue);
        }

        function setupModelAnimations(modelId, gltfObj) {
          let clips = gltfObj.animations || [];
          if (!clips.length && gltfObj.children) {
            clips = gltfObj.animations || [];
          }

          if (!AFRAME?.THREE || !clips.length) return;

          clocks[modelId] = new AFRAME.THREE.Clock();
          mixers[modelId] = new AFRAME.THREE.AnimationMixer(gltfObj);
          mixerActiveStates[modelId] = false;
          animationStates[modelId].clips = clips;

          startAnimationSequence(modelId);
          
          function animateMixer() {
            rafIds[modelId] = requestAnimationFrame(animateMixer);
            if (!mixers[modelId] || !clocks[modelId]) return;
            const delta = clocks[modelId].getDelta();
            if (mixerActiveStates[modelId]) {
              mixers[modelId].update(delta);
              
              const state = animationStates[modelId];
              if (state.currentAction && !state.isTransitioning) {
                const currentTime = state.currentAction.time;
                const clipDuration = state.currentAction.getClip().duration;
                if (currentTime >= clipDuration - state.transitionDuration - 0.1) {
                  startNextAnimation(modelId);
                }
              }
            }
          }

          if (!rafIds[modelId]) animateMixer();
        }

        function startAnimationSequence(modelId) {
          const state = animationStates[modelId];
          if (!mixers[modelId] || !state.clips.length) return;
          state.currentClipIndex = 0;
          playClip(modelId, state.currentClipIndex);
        }

        function playClip(modelId, clipIndex) {
          const state = animationStates[modelId];
          if (!mixers[modelId] || !state.clips[clipIndex]) return;
          
          if (state.currentAction) state.currentAction.stop();
          
          state.currentClipIndex = clipIndex;
          state.currentAction = mixers[modelId].clipAction(state.clips[clipIndex]);
          state.currentAction.reset();
          state.currentAction.setLoop(AFRAME.THREE.LoopOnce, 1);
          state.currentAction.clampWhenFinished = true;
          state.currentAction.play();
          state.isTransitioning = false;
        }

        function startNextAnimation(modelId) {
          const state = animationStates[modelId];
          if (state.isTransitioning || !mixers[modelId]) return;
          
          state.isTransitioning = true;
          const nextClipIndex = (state.currentClipIndex + 1) % state.clips.length;
          
          state.nextAction = mixers[modelId].clipAction(state.clips[nextClipIndex]);
          state.nextAction.reset();
          state.nextAction.setLoop(AFRAME.THREE.LoopOnce, 1);
          state.nextAction.clampWhenFinished = true;
          
          state.currentAction.crossFadeTo(state.nextAction, state.transitionDuration, false);
          state.nextAction.play();
          
          state.currentAction = state.nextAction;
          state.currentClipIndex = nextClipIndex;
          state.nextAction = null;
          
          setTimeout(() => state.isTransitioning = false, state.transitionDuration * 1000);
        }

        function playMarkerSound(soundId) {
          const soundEl = document.querySelector(`#${soundId}`);
          if (soundEl?.components?.sound) {
            const soundComponent = soundEl.components.sound;
            if (soundWasBrieflyLost[soundId]) {
              soundComponent.playSound();
              soundWasBrieflyLost[soundId] = false;
            } else {
              soundComponent.stopSound();
              soundComponent.playSound();
            }
          }
        }

        function stopMarkerSound(soundId) {
          const soundEl = document.querySelector(`#${soundId}`);
          if (soundEl?.components?.sound) {
            soundEl.components.sound.stopSound();
          }
        }

        // Event listeners
        window.addEventListener('resize', detectOrientation);
        window.addEventListener('orientationchange', detectOrientation);
        setInterval(detectOrientation, 1000);

        window.addEventListener("beforeunload", () => {
          Object.values(rafIds).forEach(rafId => rafId && cancelAnimationFrame(rafId));
          Object.values(soundTimeouts).forEach(timeout => timeout && clearTimeout(timeout));
        });

      })();
    </script>
  </body>
</html>