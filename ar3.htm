<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ARVille Web AR for Everyone!!!</title>

    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
      body { margin: 0; overflow: hidden; }
      #ar-scene { position: fixed; top:0; left:0; width:100%; height:100%; }
      #start-button {
        position: fixed; top:50%; left:50%;
        transform: translate(-50%,-50%);
        padding: 12px 22px; font-size:18px; z-index:1000;
        background:#007bff; color:white; border:none; border-radius:8px; cursor:pointer;
      }
    </style>
  </head>

  <body>
    <button id="start-button">Start AR Experience</button>

    <a-scene
      id="ar-scene"
      embedded
      arjs="debugUIEnabled: false; sourceType: webcam; patternRatio: 0.9;"
      style="display: none;"
    >
      <!-- Ambient Light for overall scene brightness -->
      <a-entity light="type: ambient; color: #888; intensity: 1"></a-entity>

      <!-- Directional Light for front illumination -->
      <a-entity light="type: directional; color: #FFFFFF; intensity: 1; position: 0 3 3" shadow></a-entity>

      <!-- Point Light for additional front fill -->
      <a-entity light="type: point; color: #FFFFFF; intensity: 1; position: 0 2 2"></a-entity>

      <!-- Markers will be generated here dynamically -->
      
      <a-entity camera></a-entity>
    </a-scene>

    <script>
      // Define all markers in a compact array
      
const markerDefinitions = [
  { id: 'girl',   pattern: 'AR/patts/mixamo/girl.patt',     model: 'AR/models/mixamo/girl.glb',     sound: 'AR/sounds/mixamo/girl.mp3',     scale: '2 2 2', position: '0 -0.4 0' },
  { id: 'mouse',  pattern: 'AR/patts/mixamo/mouse.patt',    model: 'AR/models/mixamo/mouse.glb',    sound: 'AR/sounds/mixamo/mouse.mp3',    scale: '0.3 0.15 0.3', position: '0 -0.5 0' },
  { id: 'boy', pattern: 'AR/patts/mixamo/boy.patt',   model: 'AR/models/mixamo/boy.glb',   sound: 'AR/sounds/mixamo/boy.mp3',   scale: '0.5 0.5 0.5', position: '0 -0.4 0' },
  { id: 'devil',  pattern: 'AR/patts/mixamo/devil.patt',    model: 'AR/models/mixamo/devil.glb',    sound: 'AR/sounds/mixamo/devil.mp3',    scale: '2 2 2', position: '0 -0.4 0' },
  { id: 'bones',  pattern: 'AR/patts/mixamo/bones.patt',    model: 'AR/models/mixamo/bones.glb',    sound: 'AR/sounds/mixamo/bones.mp3',    scale: '2 2 2', position: '0 -0.4 0' },
  { id: 'scarecrow', pattern: 'AR/patts/mixamo/scarecrow.patt', model: 'AR/models/mixamo/scarecrow.glb', sound: 'AR/sounds/mixamo/scarecrow.mp3', scale: '2 2 2', position: '0 -0.4 0' },
  { id: 'clown',  pattern: 'AR/patts/mixamo/clown.patt',    model: 'AR/models/mixamo/clown.glb',    sound: 'AR/sounds/mixamo/clown.mp3',    scale: '2 2 2', position: '0 -0.4 0' },
  { id: 'teddy',  pattern: 'AR/patts/mixamo/teddy.patt',    model: 'AR/models/mixamo/teddy.glb',    sound: 'AR/sounds/mixamo/teddy.mp3',    scale: '2 2 2', position: '0 -0.4 0' },
  { id: 'pumpkin', pattern: 'AR/patts/mixamo/pumpkin.patt', model: 'AR/models/mixamo/pumpkin.glb',  sound: 'AR/sounds/mixamo/pumpkin.mp3',  scale: '2 2 2', position: '0 -0.4 0' },
  { id: 'witch',  pattern: 'AR/patts/mixamo/witch.patt',    model: 'AR/models/mixamo/witch.glb',    sound: 'AR/sounds/mixamo/witch.mp3',    scale: '2 2 2', position: '0 -0.4 0' },
  { id: 'zombina', pattern: 'AR/patts/mixamo/zombina.patt', model: 'AR/models/mixamo/zombina.glb',  sound: 'AR/sounds/mixamo/zombina.mp3',  scale: '2 2 2', position: '0 -0.4 0' },
  { id: 'wolfie', pattern: 'AR/patts/mixamo/wolfie.patt',   model: 'AR/models/mixamo/wolfie.glb',   sound: 'AR/sounds/mixamo/wolfie.mp3',   scale: '2 2 2', position: '0 -0.4 0' }
];

// Generate all markers dynamically
markerDefinitions.forEach(marker => {
  const markerHTML = `
    <a-marker type="pattern" url="${marker.pattern}" id="marker-${marker.id}">
      <!-- Main container for positioning/rotation control -->
      <a-entity id="${marker.id}-container" position="0 0.6 0" rotation="0 0 0">
        <!-- Animation wrapper -->
        <a-entity
          id="${marker.id}-wrapper"
          position="0 0 0"
          rotation="-90 0 0"
          class="orientation-dependent"
        >
          <!-- Model entity -->
          <a-entity
            id="${marker.id}-model"
            gltf-model="${marker.model}"
            scale="${marker.scale}"
            position="${marker.position}"
          ></a-entity>
        </a-entity>
      </a-entity>
      <a-entity
        id="${marker.id}-sound"
        sound="src: ${marker.sound}; autoplay: false; loop: true; volume: 4; preload: auto"
      ></a-entity>
    </a-marker>
  `;
  document.querySelector('a-scene').insertAdjacentHTML('beforeend', markerHTML);
});

      (function () {
        const startButton = document.getElementById("start-button");
        const arScene = document.getElementById("ar-scene");

        // Variables for animation mixers (one per model)
        const mixers = {};
        const clocks = {};
        const rafIds = {};
        const mixerActiveStates = {};
        const animationStates = {}; // Track animation state for each model
        const soundTimeouts = {}; // Track sound timeouts for each marker
        const soundWasBrieflyLost = {}; // Track if sound was only briefly lost

        // Orientation detection
        let currentOrientation = 'unknown';
        let arInitialized = false;

        // Start AR button
        startButton.addEventListener("click", () => {
          startButton.style.display = "none";
          arScene.style.display = "block";
          arInitialized = true;
          updateAllModelDimensions();
        });

        // Helper function to define animations per model
        function getAnimationsForModel(modelName) {
          const animationSets = {
            girl: ['crisscross', 'floss', 'mj_shuffle', 'billy_bounce', 'toyman'],
            mouse: ['crisscross' , 'chacha', 'cucaracha', 'billy_bounce2'],
            boy: ['floss', 'floss', 'mj_shuffle', 'swim', 'push_step', 'chacha'],
            devil: ['shuffle', 'crisscross', 'floss', 'toyman'],
            bones: ['shuffle', 'crisscross', 'floss', 'toyman'],
            scarecrow: ['shuffle', 'crisscross', 'floss', 'toyman'],
            clown: ['shuffle', 'crisscross', 'floss', 'toyman'],
            teddy: ['shuffle', 'crisscross', 'floss', 'toyman'],
            pumpkin: ['shuffle', 'crisscross', 'floss', 'toyman'],
            witch: ['shuffle', 'crisscross', 'floss', 'toyman'],
            zombina: ['shuffle', 'crisscross', 'floss', 'toyman'],
            wolfie: ['shuffle', 'crisscross', 'floss', 'toyman']
          };
          return animationSets[modelName] || ['shuffle', 'crisscross', 'floss', 'toyman'];
        }

        // Setup all markers - each with its own animation array
        const markers = markerDefinitions.map(marker => ({
          id: `marker-${marker.id}`,
          modelId: `${marker.id}-model`,
          wrapperId: `${marker.id}-wrapper`,
          containerId: `${marker.id}-container`,
          soundId: `${marker.id}-sound`,
          modelName: marker.id,
          animations: getAnimationsForModel(marker.id)
        }));

        markers.forEach(markerConfig => {
          const marker = document.querySelector(`#${markerConfig.id}`);
          const model = document.querySelector(`#${markerConfig.modelId}`);
          const wrapper = document.querySelector(`#${markerConfig.wrapperId}`);
          const container = document.querySelector(`#${markerConfig.containerId}`);
          const soundEl = document.querySelector(`#${markerConfig.soundId}`);

          // Initialize animation state for this model with its custom animation array
          animationStates[markerConfig.modelId] = {
            animationNames: markerConfig.animations,
            clips: [],
            currentClipIndex: 0,
            currentAction: null,
            nextAction: null,
            isTransitioning: false,
            transitionDuration: 0.5,
            modelName: markerConfig.modelName
          };

          // Initialize sound tracking
          soundWasBrieflyLost[markerConfig.soundId] = false;

          // Marker found / lost events
marker.addEventListener("markerFound", () => {
  // Clear any pending stop timeout for this marker
  if (soundTimeouts[markerConfig.id]) {
    clearTimeout(soundTimeouts[markerConfig.id]);
    soundTimeouts[markerConfig.id] = null;
    soundWasBrieflyLost[markerConfig.soundId] = true;
  }
  
  // Start animations for this model
  if (mixers[markerConfig.modelId]) {
    mixerActiveStates[markerConfig.modelId] = true;
  }
  
  // Fix male model orientation by adjusting container AND wrapper
  fixModelOrientation(markerConfig.modelId, markerConfig.containerId, markerConfig.wrapperId);
  
  // Play individual sound for this marker
  playMarkerSound(markerConfig.soundId);
});

          marker.addEventListener("markerLost", () => {
            // Pause animations for this model
            if (mixers[markerConfig.modelId]) {
              mixerActiveStates[markerConfig.modelId] = false;
            }
            
            // Reset the brief loss flag
            soundWasBrieflyLost[markerConfig.soundId] = false;
            
            // Set timeout to stop music permanently after 1 second for this marker
            soundTimeouts[markerConfig.id] = setTimeout(() => {
              stopMarkerSound(markerConfig.soundId);
              soundTimeouts[markerConfig.id] = null;
            }, 1000);
          });

          // Model loaded event
          model.addEventListener("model-loaded", (e) => {
            setupModelAnimations(markerConfig.modelId, e.detail.model, markerConfig.modelName, markerConfig.animations);
          });

          // Store wrapper for orientation updates
          marker.wrapper = wrapper;
        });

        function detectOrientation() {
          if (typeof window.orientation !== 'undefined') {
            currentOrientation = Math.abs(window.orientation) === 90 ? 'landscape' : 'portrait';
          } else if (window.screen && window.screen.orientation && window.screen.orientation.type) {
            currentOrientation = window.screen.orientation.type.includes('landscape') ? 'landscape' : 'portrait';
          } else {
            currentOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
          }
          
          if (arInitialized) {
            updateAllModelDimensions();
          }
          
          return currentOrientation;
        }

        function updateAllModelDimensions() {
          markers.forEach(markerConfig => {
            const wrapper = document.querySelector(`#${markerConfig.wrapperId}`);
            if (wrapper) {
              updateModelDimensions(wrapper);
            }
          });
        }

        function updateModelDimensions(wrapper) {
          if (!wrapper) return;
          
          let scaleValue;
          if (currentOrientation === 'portrait') {
            scaleValue = '2 0.8 2';
          } else {
            scaleValue = '1 1.8 1';
          }
          
          wrapper.setAttribute('scale', scaleValue);
        }

        async function setupModelAnimations(modelId, gltfObj, modelName, animationNames) {
          if (!AFRAME || !AFRAME.THREE) {
            return;
          }

          // Use the provided animation names array (completely independent of embedded animations)
          console.log(`&#127916; Setting up animations for ${modelName}:`, animationNames);
          
          // Load external JSON animations
          const loadedClips = [];
          
          for (const animName of animationNames) {
            try {
              const clip = await loadAnimationClip(modelName, animName, gltfObj);
              if (clip) {
                loadedClips.push(clip);
                console.log(`&#9989; Loaded animation: ${animName} for ${modelName}`);
              }
            } catch (error) {
              console.warn(`&#9888;&#65039; Failed to load animation ${animName} for ${modelName}:`, error);
            }
          }

          if (loadedClips.length === 0) {
            console.warn(`&#9888;&#65039; No animations loaded for ${modelName}`);
            return;
          }

          // Create clock and mixer for this model
          clocks[modelId] = new AFRAME.THREE.Clock();
          mixers[modelId] = new AFRAME.THREE.AnimationMixer(gltfObj);
          mixerActiveStates[modelId] = false;
          animationStates[modelId].clips = loadedClips;

          // Start with the first animation
          startAnimationSequence(modelId);
          
          // Start the animation update loop for this model
          function animateMixer() {
            rafIds[modelId] = requestAnimationFrame(animateMixer);
            if (!mixers[modelId] || !clocks[modelId]) return;
            const delta = clocks[modelId].getDelta();
            if (mixerActiveStates[modelId]) {
              mixers[modelId].update(delta);
              
              // Check if we should transition to next animation
              const state = animationStates[modelId];
              if (state.currentAction && !state.isTransitioning) {
                const currentTime = state.currentAction.time;
                const clipDuration = state.currentAction.getClip().duration;
                
                // Start transition before current animation ends
                if (currentTime >= clipDuration - state.transitionDuration - 0.1) {
                  startNextAnimation(modelId);
                }
              }
            }
          }

          // Start loop
          if (!rafIds[modelId]) animateMixer();
        }

async function loadAnimationClip(modelName, animName, gltfObj) {
  return new Promise((resolve, reject) => {
    const animationPath = `AR/animations/mixamo/${animName}.json`;
    
    console.log(`&#128193; Loading animation from: ${animationPath}`);
    
    fetch(animationPath)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Failed to load ${animName}.json`);
        }
        return response.json();
      })
      .then(animationData => {
        // Filter out problematic tracks
        const tracks = animationData.tracks.map(trackData => {
          // Remove ALL scale tracks
          if (trackData.name.includes('.scale')) {
            console.log(`&#128683; Filtered out scale track: ${trackData.name}`);
            return null;
          }
          
// Remove ONLY the root bone rotations that cause flipping - DIFFERENT PER MODEL
if (trackData.name.includes('.quaternion')) {
  const boneName = trackData.name.split('.')[0];
  
  // Different filtering for different models
  if (modelName === 'mouse') {
    // Mouse needs spine bones filtered to prevent tilting
    if (boneName === 'mixamorigHips' || boneName === 'mixamorigSpine2') {
      console.log(`&#128045; Filtered out mouse bone: ${trackData.name}`);
      return null;
    }
  } else {
    // Other models only need hips filtered
    if (boneName === 'mixamorigHips') {
      console.log(`&#128683; Filtered out root bone: ${trackData.name}`);
      return null;
    }
  }
}          
          return new AFRAME.THREE.KeyframeTrack(
            trackData.name,
            new Float32Array(trackData.times),
            new Float32Array(trackData.values)
          );
        }).filter(track => track !== null);

        // Debug: Show what bones remain
        const remainingBones = tracks
          .filter(track => track && track.name.includes('.quaternion'))
          .map(track => track.name.split('.')[0])
          .filter((name, index, array) => array.indexOf(name) === index);
        
        console.log(`&#9989; ${animName} - Remaining tracks: ${tracks.length}`);
        console.log(`&#129460; Animating bones:`, remainingBones);
        
        const clip = new AFRAME.THREE.AnimationClip(
          animName,
          animationData.duration,
          tracks
        );
        
        resolve(clip);
      })
      .catch(error => {
        reject(error);
      });
  });
}


        function startAnimationSequence(modelId) {
          const state = animationStates[modelId];
          if (!mixers[modelId] || state.clips.length === 0) return;
          
          state.currentClipIndex = 0;
          playClip(modelId, state.currentClipIndex);
        }

        function playClip(modelId, clipIndex) {
          const state = animationStates[modelId];
          if (!mixers[modelId] || !state.clips[clipIndex]) return;
          
          // Stop any current action immediately
          if (state.currentAction) {
            state.currentAction.stop();
          }
          
          // Play new clip
          state.currentClipIndex = clipIndex;
          state.currentAction = mixers[modelId].clipAction(state.clips[clipIndex]);
          state.currentAction.reset();
          state.currentAction.setLoop(AFRAME.THREE.LoopOnce, 1);
          state.currentAction.clampWhenFinished = true;
          state.currentAction.play();
          
          state.isTransitioning = false;
        }

        function startNextAnimation(modelId) {
          const state = animationStates[modelId];
          if (state.isTransitioning || !mixers[modelId]) return;
          
          state.isTransitioning = true;
          const nextClipIndex = (state.currentClipIndex + 1) % state.clips.length;
          
          // Prepare the next action
          state.nextAction = mixers[modelId].clipAction(state.clips[nextClipIndex]);
          state.nextAction.reset();
          state.nextAction.setLoop(AFRAME.THREE.LoopOnce, 1);
          state.nextAction.clampWhenFinished = true;
          
          // Use a much shorter, less exaggerated crossfade
          const quickTransitionDuration = 0.3;
          
          // Crossfade from current to next with minimal blending
          state.currentAction.crossFadeTo(state.nextAction, quickTransitionDuration, false);
          state.nextAction.play();
          
          // Update current references
          state.currentAction = state.nextAction;
          state.currentClipIndex = nextClipIndex;
          state.nextAction = null;
          
          // Reset transitioning flag after crossfade completes
          setTimeout(() => {
            state.isTransitioning = false;
          }, quickTransitionDuration * 1000);
        }

        // Sound control functions for individual markers
        function playMarkerSound(soundId) {
          const soundEl = document.querySelector(`#${soundId}`);
          if (soundEl) {
            const soundComponent = soundEl.components.sound;
            if (soundComponent) {
              if (soundWasBrieflyLost[soundId]) {
                soundComponent.playSound();
                soundWasBrieflyLost[soundId] = false;
              } else {
                soundComponent.stopSound();
                soundComponent.playSound();
              }
            }
          }
        }

        function stopMarkerSound(soundId) {
          const soundEl = document.querySelector(`#${soundId}`);
          if (soundEl) {
            const soundComponent = soundEl.components.sound;
            if (soundComponent) {
              soundComponent.stopSound();
            }
          }
        }

        // Set up orientation change listeners
        window.addEventListener('resize', detectOrientation);
        window.addEventListener('orientationchange', detectOrientation);
        setInterval(detectOrientation, 1000);

        // Clean up on unload
        window.addEventListener("beforeunload", () => {
          Object.values(rafIds).forEach(rafId => {
            if (rafId) cancelAnimationFrame(rafId);
          });
          Object.values(soundTimeouts).forEach(timeout => {
            if (timeout) clearTimeout(timeout);
          });
        });

      })();
    </script>
  </body>
</html>