<!DOCTYPE html>
<html>
  <head>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="AR/dist/aframe-chromakey-material.min.js"></script>
    <style>
      #ar-scene {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #start-button {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 15px 30px;
        font-size: 18px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        z-index: 1000;
      }
      #orientation-display {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        z-index: 1001;
        font-family: Arial, sans-serif;
      }
    </style>
  </head>

  <body style="margin: 0px; overflow: hidden;">
    <!-- Orientation Display -->
    <div id="orientation-display">
      Detecting orientation...
    </div>

    <!-- Start Button -->
    <button id="start-button">Start AR Experience</button>

    <!-- A-Frame Scene with newer AR.js and pattern ratio -->
    <a-scene id="ar-scene" 
             arjs="debugUIEnabled: false; 
                   sourceType: webcam;
                   patternRatio: 0.9;"
             embedded
             style="display: none;">
    
      <!-- First Marker - Frankie -->
      <a-marker type="pattern" url="AR/patts/frankie.patt" id="marker-frankie">
        <a-plane
          material="shader: chromakey; src: #video-frankie; color: 0.9 0 0.1"
          position="0 0 0"
          rotation="-90 0 0"
          class="orientation-dependent"
        ></a-plane>
      </a-marker>

      <a-marker type="pattern" url="AR/patts/zombie.patt" id="marker-zombie">
        <a-plane
          material="shader: chromakey; src: #video-zombie; color: 0.9 0 0.1"
          position="0 0 0"
          rotation="-90 0 0"
          class="orientation-dependent"
        ></a-plane>
      </a-marker>

      <!-- Second Marker - Vamp -->
      <a-marker type="pattern" url="AR/patts/vamp.patt" id="marker-vamp">
        <a-plane
          material="shader: chromakey; src: #video-vamp; color: 0.1 0.9 0.2"
          position="0 0 0"
          rotation="-90 0 0"
          class="orientation-dependent"
        ></a-plane>
      </a-marker>

      <!-- New Marker - Devil -->
      <a-marker type="pattern" url="AR/patts/devil.patt" id="marker-devil">
        <a-plane
          material="shader: chromakey; src: #video-devil; color: 0.9 0.1 0.1"
          position="0 0 0"
          rotation="-90 0 0"
          class="orientation-dependent"
        ></a-plane>
      </a-marker>

      <!-- New Marker - Bones -->
      <a-marker type="pattern" url="AR/patts/bones.patt" id="marker-bones">
        <a-plane
          material="shader: chromakey; src: #video-bones; color: 0.8 0.8 0.8"
          position="0 0 0"
          rotation="-90 0 0"
          class="orientation-dependent"
        ></a-plane>
      </a-marker>

      <!-- New Marker - Scarecrow -->
      <a-marker type="pattern" url="AR/patts/scarecrow.patt" id="marker-scarecrow">
        <a-plane
          material="shader: chromakey; src: #video-scarecrow; color: 0.7 0.5 0.1"
          position="0 0 0"
          rotation="-90 0 0"
          class="orientation-dependent"
        ></a-plane>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>

    <!-- Hidden Video Elements - COMPLETELY HIDDEN -->
    <video
      id="video-frankie"
      src="AR/videos/frankie2-rs.mp4"
      loop
      muted
      preload="none"
      playsinline
      style="display: none; position: absolute; top: -9999px; left: -9999px; width: 1px; height: 1px;"
    ></video>

    <video
      id="video-vamp"
      src="AR/videos/vamp5-gs.mp4"
      loop
      muted
      preload="none"
      playsinline
      style="display: none; position: absolute; top: -9999px; left: -9999px; width: 1px; height: 1px;"
    ></video>

    <video
      id="video-zombie"
      src="AR/videos/zombie3-rs.mp4"
      loop
      muted
      preload="none"
      playsinline
      style="display: none; position: absolute; top: -9999px; left: -9999px; width: 1px; height: 1px;"
    ></video>
    
    <!-- New Video Elements for Added Markers -->
    <video
      id="video-devil"
      src="AR/videos/devil.mp4"
      loop
      muted
      preload="none"
      playsinline
      style="display: none; position: absolute; top: -9999px; left: -9999px; width: 1px; height: 1px;"
    ></video>

    <video
      id="video-bones"
      src="AR/videos/bones.mp4"
      loop
      muted
      preload="none"
      playsinline
      style="display: none; position: absolute; top: -9999px; left: -9999px; width: 1px; height: 1px;"
    ></video>

    <video
      id="video-scarecrow"
      src="AR/videos/scarecrow.mp4"
      loop
      muted
      preload="none"
      playsinline
      style="display: none; position: absolute; top: -9999px; left: -9999px; width: 1px; height: 1px;"
    ></video>
    
    <script>
      // Global orientation variable
      let currentOrientation = 'unknown';
      
      window.addEventListener("DOMContentLoaded", function () {
        const startButton = document.getElementById('start-button');
        const arScene = document.getElementById('ar-scene');
        const orientationDisplay = document.getElementById('orientation-display');
        const videoFrankie = document.querySelector("#video-frankie");
        const videoVamp = document.querySelector("#video-vamp");
        const videoZombie = document.querySelector("#video-zombie");
        const videoDevil = document.querySelector("#video-devil");
        const videoBones = document.querySelector("#video-bones");
        const videoScarecrow = document.querySelector("#video-scarecrow");
        
        // Select marker elements
        const markerFrankie = document.querySelector("#marker-frankie");
        const markerVamp = document.querySelector("#marker-vamp");
        const markerZombie = document.querySelector("#marker-zombie");
        const markerDevil = document.querySelector("#marker-devil");
        const markerBones = document.querySelector("#marker-bones");
        const markerScarecrow = document.querySelector("#marker-scarecrow");
        
        let arInitialized = false;
        const activeVideos = new Map(); // Track video states and intervals
        
        // Detect orientation on load
        detectOrientation();
        
        // Set up orientation change listener
        window.addEventListener('resize', detectOrientation);
        window.addEventListener('orientationchange', detectOrientation);
        // Add continuous checking for Android
        setInterval(detectOrientation, 1000);
        
        // Start button click handler - directly start AR
        startButton.addEventListener('click', function() {
          startButton.style.display = 'none';
          arScene.style.display = 'block';
          initializeAR();
        });
        
        function detectOrientation() {
          // Method 1: Check window.orientation (deprecated but still widely supported)
          if (typeof window.orientation !== 'undefined') {
            currentOrientation = Math.abs(window.orientation) === 90 ? 'landscape' : 'portrait';
          } 
          // Method 2: Check screen dimensions
          else if (window.screen && window.screen.orientation && window.screen.orientation.type) {
            currentOrientation = window.screen.orientation.type.includes('landscape') ? 'landscape' : 'portrait';
          }
          // Method 3: Check window dimensions as fallback
          else {
            currentOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
          }
          
          // Update display
          orientationDisplay.innerHTML = `${currentOrientation.toUpperCase()}`;
          
          // ALWAYS update plane dimensions when orientation changes
          updatePlaneDimensions();
          
          return currentOrientation;
        }
        
        function updatePlaneDimensions() {
          const planes = document.querySelectorAll('.orientation-dependent');
          
          console.log(`Updating plane dimensions for: ${currentOrientation}`);
          
          planes.forEach(plane => {
            if (currentOrientation === 'portrait') {
              // PORTRAIT: Wider width, shorter height
              if (plane.parentElement.id === 'marker-frankie') {
                plane.setAttribute('width', '4');  // Wider
                plane.setAttribute('height', '1.97'); // Shorter
              } else if (plane.parentElement.id === 'marker-zombie') {
                plane.setAttribute('width', '4');  // Wider
                plane.setAttribute('height', '1.71'); // Shorter
              } else if (plane.parentElement.id === 'marker-vamp') {
                plane.setAttribute('width', '4');  // Wider
                plane.setAttribute('height', '1.7'); // Shorter
              } else if (plane.parentElement.id === 'marker-devil') {
                plane.setAttribute('width', '4');  // Wider
                plane.setAttribute('height', '1.8'); // Shorter
              } else if (plane.parentElement.id === 'marker-bones') {
                plane.setAttribute('width', '4');  // Wider
                plane.setAttribute('height', '1.9'); // Shorter
              } else if (plane.parentElement.id === 'marker-scarecrow') {
                plane.setAttribute('width', '4');  // Wider
                plane.setAttribute('height', '1.85'); // Shorter
              }
            } else {
              // LANDSCAPE: Narrower width, taller height
              if (plane.parentElement.id === 'marker-frankie') {
                plane.setAttribute('width', '2.5');  // Narrower
                plane.setAttribute('height', '3.3'); // Taller
              } else if (plane.parentElement.id === 'marker-zombie') {
                plane.setAttribute('width', '2.5');  // Narrower
                plane.setAttribute('height', '2.85'); // Taller
              } else if (plane.parentElement.id === 'marker-vamp') {
                plane.setAttribute('width', '2.5');  // Narrower
                plane.setAttribute('height', '2.8'); // Taller
              } else if (plane.parentElement.id === 'marker-devil') {
                plane.setAttribute('width', '2.5');  // Narrower
                plane.setAttribute('height', '3.0'); // Taller
              } else if (plane.parentElement.id === 'marker-bones') {
                plane.setAttribute('width', '2.5');  // Narrower
                plane.setAttribute('height', '3.2'); // Taller
              } else if (plane.parentElement.id === 'marker-scarecrow') {
                plane.setAttribute('width', '2.5');  // Narrower
                plane.setAttribute('height', '3.1'); // Taller
              }
            }
            console.log(`Updated ${plane.parentElement.id}: ${plane.getAttribute('width')} x ${plane.getAttribute('height')}`);
          });
        }
        
        function initializeAR() {
          arInitialized = true;
          
          // Update plane dimensions based on current orientation
          updatePlaneDimensions();
          
          // Set up marker events
          setupMarkerEvents();
        }
        
        function setupMarkerEvents() {
          // Frankie marker events
          markerFrankie.addEventListener("markerFound", function () {
            if (!arInitialized) return;
            // Clear any pending deactivation timeout
            if (this.deactivationTimeout) {
              clearTimeout(this.deactivationTimeout);
              this.deactivationTimeout = null;
            }
            activateVideo(videoFrankie, "Frankie");
          });
          
          markerFrankie.addEventListener("markerLost", function () {
            // Delay deactivation by 2 seconds
            this.deactivationTimeout = setTimeout(() => {
              deactivateVideo(videoFrankie, "Frankie");
            }, 1000);
          });

          // Vamp marker events
          markerVamp.addEventListener("markerFound", function () {
            if (!arInitialized) return;
            // Clear any pending deactivation timeout
            if (this.deactivationTimeout) {
              clearTimeout(this.deactivationTimeout);
              this.deactivationTimeout = null;
            }
            activateVideo(videoVamp, "Vamp");
          });
          
          markerVamp.addEventListener("markerLost", function () {
            // Delay deactivation by 2 seconds
            this.deactivationTimeout = setTimeout(() => {
              deactivateVideo(videoVamp, "Vamp");
            }, 1000);
          });
          
          // Zombie marker events
          markerZombie.addEventListener("markerFound", function () {
            if (!arInitialized) return;
            // Clear any pending deactivation timeout
            if (this.deactivationTimeout) {
              clearTimeout(this.deactivationTimeout);
              this.deactivationTimeout = null;
            }
            activateVideo(videoZombie, "Zombie");
          });
          
          markerZombie.addEventListener("markerLost", function () {
            // Delay deactivation by 2 seconds
            this.deactivationTimeout = setTimeout(() => {
              deactivateVideo(videoZombie, "Zombie");
            }, 1000);
          });
          
          // Devil marker events
          markerDevil.addEventListener("markerFound", function () {
            if (!arInitialized) return;
            // Clear any pending deactivation timeout
            if (this.deactivationTimeout) {
              clearTimeout(this.deactivationTimeout);
              this.deactivationTimeout = null;
            }
            activateVideo(videoDevil, "Devil");
          });
          
          markerDevil.addEventListener("markerLost", function () {
            // Delay deactivation by 2 seconds
            this.deactivationTimeout = setTimeout(() => {
              deactivateVideo(videoDevil, "Devil");
            }, 1000);
          });
          
          // Bones marker events
          markerBones.addEventListener("markerFound", function () {
            if (!arInitialized) return;
            // Clear any pending deactivation timeout
            if (this.deactivationTimeout) {
              clearTimeout(this.deactivationTimeout);
              this.deactivationTimeout = null;
            }
            activateVideo(videoBones, "Bones");
          });
          
          markerBones.addEventListener("markerLost", function () {
            // Delay deactivation by 2 seconds
            this.deactivationTimeout = setTimeout(() => {
              deactivateVideo(videoBones, "Bones");
            }, 1000);
          });
          
          // Scarecrow marker events
          markerScarecrow.addEventListener("markerFound", function () {
            if (!arInitialized) return;
            // Clear any pending deactivation timeout
            if (this.deactivationTimeout) {
              clearTimeout(this.deactivationTimeout);
              this.deactivationTimeout = null;
            }
            activateVideo(videoScarecrow, "Scarecrow");
          });
          
          markerScarecrow.addEventListener("markerLost", function () {
            // Delay deactivation by 2 seconds
            this.deactivationTimeout = setTimeout(() => {
              deactivateVideo(videoScarecrow, "Scarecrow");
            }, 1000);
          });
        }        

        function activateVideo(video, videoName) {
          console.log(`Activating ${videoName}`);
          
          // UNMUTE the video
          video.muted = false;
          
          // If already active, just ensure it's playing and unmuted
          if (activeVideos.has(video)) {
            console.log(`${videoName} already active, ensuring playback`);
            video.play().catch(e => console.log(`Playback ensure failed:`, e));
            return;
          }
          
          // Store video state
          activeVideos.set(video, {
            name: videoName,
            fullyLoaded: false,
            bufferingInterval: null
          });
          
          // Set up aggressive buffering - BUT DON'T CALL video.load()!
          video.preload = 'auto';
          
          const playVideo = () => {
            video.play().then(() => {
              console.log(`${videoName} started playing`);
            }).catch(e => {
              console.log(`${videoName} autoplay prevented:`, e);
              // Keep retrying until it plays
              setTimeout(playVideo, 500);
            });
          };
          
          playVideo();
          
          // CRITICAL FIX: Handle waiting event to resume playback automatically
          let waitingForBuffer = false;
          
          video.addEventListener('waiting', function() {
            console.log(`${videoName} is waiting for data - will auto-resume`);
            waitingForBuffer = true;
            
            // Set up a listener for when enough data is buffered
            const onCanPlay = () => {
              if (waitingForBuffer) {
                console.log(`${videoName} has enough data, resuming from current position`);
                video.play().catch(e => console.log('Resume play failed:', e));
                waitingForBuffer = false;
              }
            };
            
            video.addEventListener('canplay', onCanPlay);
            
            // Remove the listener after it fires once
            setTimeout(() => {
              video.removeEventListener('canplay', onCanPlay);
            }, 5000);
          });
          
          // Handle when playback actually resumes
          video.addEventListener('playing', function() {
            waitingForBuffer = false;
            console.log(`${videoName} is now playing`);
          });
          
          // Set up buffering progress monitoring (without resetting the video)
          const bufferingInterval = setInterval(() => {
            if (video.buffered.length > 0) {
              const bufferedEnd = video.buffered.end(video.buffered.length - 1);
              const duration = video.duration;
              const currentTime = video.currentTime;
              
              if (duration > 0 && !isNaN(duration)) {
                const percentLoaded = (bufferedEnd / duration) * 100;
                const secondsAhead = bufferedEnd - currentTime;
                
                if (percentLoaded < 100) {
                  console.log(`${videoName} buffering: ${percentLoaded.toFixed(1)}% (${secondsAhead.toFixed(1)}s ahead)`);
                  
                  // If buffer is getting low but video is not actively buffering, nudge it
                  if (secondsAhead < 3 && video.networkState === video.NETWORK_IDLE) {
                    console.log(`${videoName} - low buffer, encouraging more buffering`);
                    // Just access the buffered property to encourage browser to buffer more
                    const buffered = video.buffered;
                  }
                } else {
                  console.log(`${videoName} fully loaded!`);
                  const state = activeVideos.get(video);
                  state.fullyLoaded = true;
                }
              }
            }
            
            // If video is stuck but should be playing, try to resume
            if (video.paused && !waitingForBuffer && video.readyState >= 3 && !video.ended) {
              console.log(`${videoName} is paused but has data - resuming`);
              video.play().catch(e => console.log('Stuck recovery failed:', e));
            }
          }, 2000); // Check every 2 seconds
          
          // Store the interval for cleanup
          const state = activeVideos.get(video);
          state.bufferingInterval = bufferingInterval;
          
          video.addEventListener('canplaythrough', function() {
            console.log(`${videoName} can play through without stopping`);
          });
          
          video.addEventListener('stalled', function() {
            console.log(`${videoName} stalled - will auto-resume when data available`);
            waitingForBuffer = true;
          });
        }
        
        function deactivateVideo(video, videoName) {
          if (!activeVideos.has(video)) return;
          
          console.log(`Deactivating ${videoName}`);
          const state = activeVideos.get(video);
          
          // Mute the video but KEEP IT IN activeVideos
          video.muted = true;
        }
      });
    </script>
  </body>
</html>