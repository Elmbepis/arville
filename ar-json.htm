<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ARVille AR for Everyone!!!</title>

    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
      body { margin: 0; overflow: hidden; }
      #ar-scene { position: fixed; top:0; left:0; width:100%; height:100%; }
      #start-button {
        position: fixed; top:50%; left:50%;
        transform: translate(-50%,-50%);
        padding: 12px 22px; font-size:18px; z-index:1000;
        background:#007bff; color:white; border:none; border-radius:8px; cursor:pointer;
      }
    </style>
  </head>

  <body>
    <button id="start-button">Start AR Experience</button>

    <a-scene
      id="ar-scene"
      embedded
      arjs="debugUIEnabled: false; sourceType: webcam; patternRatio: 0.9;"
      style="display: none;"
    >
      <!-- Ambient Light for overall scene brightness -->
      <a-entity light="type: ambient; color: #888; intensity: 1"></a-entity>

      <!-- Directional Light for front illumination -->
      <a-entity light="type: directional; color: #FFFFFF; intensity: 1.5; position: 0 3 3" shadow></a-entity>

      <!-- Point Light for additional front fill -->
      <a-entity light="type: point; color: #FFFFFF; intensity: 1.5; position: 0 2 2"></a-entity>

      <!-- Markers will be generated here dynamically -->
      
      <a-entity camera></a-entity>
    </a-scene>

    <script>
      // Define all markers in a compact array
      const markerDefinitions = [
        { id: 'vamp', pattern: 'AR/patts/horror/vamp.patt', model: 'AR/models/horror/vamp.glb', sound: 'AR/sounds/horror/vamp.mp3' },
        { id: 'frankie', pattern: 'AR/patts/horror/frankie.patt', model: 'AR/models/horror/frankie.glb', sound: 'AR/sounds/horror/frankie.mp3' },
        { id: 'zombie', pattern: 'AR/patts/horror/zombie.patt', model: 'AR/models/horror/zombie.glb', sound: 'AR/sounds/horror/zombie.mp3' },
        { id: 'devil', pattern: 'AR/patts/horror/devil.patt', model: 'AR/models/horror/devil.glb', sound: 'AR/sounds/horror/devil.mp3' },
        { id: 'bones', pattern: 'AR/patts/horror/bones.patt', model: 'AR/models/horror/bones.glb', sound: 'AR/sounds/horror/bones.mp3' },
        { id: 'scarecrow', pattern: 'AR/patts/horror/scarecrow.patt', model: 'AR/models/horror/scarecrow.glb', sound: 'AR/sounds/horror/scarecrow.mp3' },
        { id: 'clown', pattern: 'AR/patts/horror/clown.patt', model: 'AR/models/horror/clown.glb', sound: 'AR/sounds/horror/clown.mp3' },
        { id: 'teddy', pattern: 'AR/patts/horror/teddy.patt', model: 'AR/models/horror/teddy.glb', sound: 'AR/sounds/horror/teddy.mp3' },
        { id: 'pumpkin', pattern: 'AR/patts/horror/pumpkin.patt', model: 'AR/models/horror/pumpkin.glb', sound: 'AR/sounds/horror/pumpkin.mp3' },
        { id: 'witch', pattern: 'AR/patts/horror/witch.patt', model: 'AR/models/horror/witch.glb', sound: 'AR/sounds/horror/witch.mp3' },
        { id: 'zombina', pattern: 'AR/patts/horror/zombina.patt', model: 'AR/models/horror/zombina.glb', sound: 'AR/sounds/horror/zombina.mp3' },
        { id: 'wolfie', pattern: 'AR/patts/horror/wolfie.patt', model: 'AR/models/horror/wolfie.glb', sound: 'AR/sounds/horror/wolfie.mp3' }
      ];

      // Generate all markers dynamically
      markerDefinitions.forEach(marker => {
        const markerHTML = `
          <a-marker type="pattern" url="${marker.pattern}" id="marker-${marker.id}">
            <!-- Main container for positioning/rotation control -->
            <a-entity id="${marker.id}-container" position="0 0.6 0" rotation="0 0 0">
              <!-- Animation wrapper -->
              <a-entity
                id="${marker.id}-wrapper"
                position="0 0 0"
                rotation="-90 0 0"
                class="orientation-dependent"
              >
                <!-- Model entity -->
                <a-entity
                  id="${marker.id}-model"
                  gltf-model="${marker.model}"
                  scale="4 4 4"
                  position="0 -0.6 0"
                ></a-entity>
              </a-entity>
            </a-entity>
            <a-entity
              id="${marker.id}-sound"
              sound="src: ${marker.sound}; autoplay: false; loop: true; volume: 4; preload: auto"
            ></a-entity>
          </a-marker>
        `;
        document.querySelector('a-scene').insertAdjacentHTML('beforeend', markerHTML);
      });

      (function () {
        const startButton = document.getElementById("start-button");
        const arScene = document.getElementById("ar-scene");

        // Variables for animation mixers (one per model)
        const mixers = {};
        const clocks = {};
        const rafIds = {};
        const mixerActiveStates = {};
        const animationStates = {}; // Track animation state for each model
        const soundTimeouts = {}; // Track sound timeouts for each marker
        const soundWasBrieflyLost = {}; // Track if sound was only briefly lost

        // Orientation detection
        let currentOrientation = 'unknown';
        let arInitialized = false;

        // Start AR button
        startButton.addEventListener("click", () => {
          startButton.style.display = "none";
          arScene.style.display = "block";
          arInitialized = true;
          updateAllModelDimensions();
        });

        // Helper function to define animations per model
        function getAnimationsForModel(modelName) {
          const animationSets = {
            vamp: ['shuffle', 'crisscross', 'floss', 'floss', 'toyman'],
            frankie: ['shuffle', 'crisscross', 'floss', 'toyman'],
            zombie: ['shuffle', 'crisscross', 'floss', 'toyman'],
            devil: ['shuffle', 'crisscross', 'floss', 'toyman'],
            bones: ['shuffle', 'crisscross', 'floss', 'toyman'],
            scarecrow: ['shuffle', 'crisscross', 'floss', 'toyman'],
            clown: ['shuffle', 'crisscross', 'floss', 'toyman'],
            teddy: ['shuffle', 'crisscross', 'floss', 'toyman'],
            pumpkin: ['shuffle', 'crisscross', 'floss', 'toyman'],
            witch: ['shuffle', 'crisscross', 'floss', 'toyman'],
            zombina: ['shuffle', 'crisscross', 'floss', 'toyman'],
            wolfie: ['shuffle', 'crisscross', 'floss', 'toyman']
          };
          return animationSets[modelName] || ['shuffle', 'crisscross', 'floss', 'toyman'];
        }

        // Setup all markers - each with its own animation array
        const markers = markerDefinitions.map(marker => ({
          id: `marker-${marker.id}`,
          modelId: `${marker.id}-model`,
          wrapperId: `${marker.id}-wrapper`,
          containerId: `${marker.id}-container`,
          soundId: `${marker.id}-sound`,
          modelName: marker.id,
          animations: getAnimationsForModel(marker.id)
        }));

        markers.forEach(markerConfig => {
          const marker = document.querySelector(`#${markerConfig.id}`);
          const model = document.querySelector(`#${markerConfig.modelId}`);
          const wrapper = document.querySelector(`#${markerConfig.wrapperId}`);
          const container = document.querySelector(`#${markerConfig.containerId}`);
          const soundEl = document.querySelector(`#${markerConfig.soundId}`);

          // Initialize animation state for this model with its custom animation array
          animationStates[markerConfig.modelId] = {
            animationNames: markerConfig.animations,
            clips: [],
            currentClipIndex: 0,
            currentAction: null,
            nextAction: null,
            isTransitioning: false,
            transitionDuration: 0.5,
            modelName: markerConfig.modelName
          };

          // Initialize sound tracking
          soundWasBrieflyLost[markerConfig.soundId] = false;

          // Marker found / lost events
marker.addEventListener("markerFound", () => {
  // Clear any pending stop timeout for this marker
  if (soundTimeouts[markerConfig.id]) {
    clearTimeout(soundTimeouts[markerConfig.id]);
    soundTimeouts[markerConfig.id] = null;
    soundWasBrieflyLost[markerConfig.soundId] = true;
  }
  
  // Start animations for this model
  if (mixers[markerConfig.modelId]) {
    mixerActiveStates[markerConfig.modelId] = true;
  }
  
  // Fix male model orientation by adjusting container AND wrapper
  fixModelOrientation(markerConfig.modelId, markerConfig.containerId, markerConfig.wrapperId);
  
  // Play individual sound for this marker
  playMarkerSound(markerConfig.soundId);
});

          marker.addEventListener("markerLost", () => {
            // Pause animations for this model
            if (mixers[markerConfig.modelId]) {
              mixerActiveStates[markerConfig.modelId] = false;
            }
            
            // Reset the brief loss flag
            soundWasBrieflyLost[markerConfig.soundId] = false;
            
            // Set timeout to stop music permanently after 1 second for this marker
            soundTimeouts[markerConfig.id] = setTimeout(() => {
              stopMarkerSound(markerConfig.soundId);
              soundTimeouts[markerConfig.id] = null;
            }, 1000);
          });

          // Model loaded event
          model.addEventListener("model-loaded", (e) => {
            setupModelAnimations(markerConfig.modelId, e.detail.model, markerConfig.modelName, markerConfig.animations);
          });

          // Store wrapper for orientation updates
          marker.wrapper = wrapper;
        });


function fixModelOrientation(modelId, containerId, wrapperId) {
  const container = document.querySelector(`#${containerId}`);
  const wrapper = document.querySelector(`#${wrapperId}`);
  
  if (container && wrapper) {
    const modelName = modelId.replace('-model', '');
    const maleModels = ['frankie', 'zombie', 'devil', 'bones', 'scarecrow', 'clown', 'wolfie'];
    
    if (maleModels.includes(modelName)) {
      // Adjust container for rotation
      container.setAttribute('rotation', '90 0 0');
      container.setAttribute('scale', '2 3 2');
      
      // Adjust WRAPPER position instead - this moves the model within the container
      wrapper.setAttribute('position', '0 0.7 0');
    }
  }
}

        function detectOrientation() {
          if (typeof window.orientation !== 'undefined') {
            currentOrientation = Math.abs(window.orientation) === 90 ? 'landscape' : 'portrait';
          } else if (window.screen && window.screen.orientation && window.screen.orientation.type) {
            currentOrientation = window.screen.orientation.type.includes('landscape') ? 'landscape' : 'portrait';
          } else {
            currentOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
          }
          
          if (arInitialized) {
            updateAllModelDimensions();
          }
          
          return currentOrientation;
        }

        function updateAllModelDimensions() {
          markers.forEach(markerConfig => {
            const wrapper = document.querySelector(`#${markerConfig.wrapperId}`);
            if (wrapper) {
              updateModelDimensions(wrapper);
            }
          });
        }

        function updateModelDimensions(wrapper) {
          if (!wrapper) return;
          
          let scaleValue;
          if (currentOrientation === 'portrait') {
            scaleValue = '2 0.8 2';
          } else {
            scaleValue = '1 1.8 1';
          }
          
          wrapper.setAttribute('scale', scaleValue);
        }

        async function setupModelAnimations(modelId, gltfObj, modelName, animationNames) {
          if (!AFRAME || !AFRAME.THREE) {
            return;
          }

          // Use the provided animation names array (completely independent of embedded animations)
          console.log(`&#127916; Setting up animations for ${modelName}:`, animationNames);
          
          // Load external JSON animations
          const loadedClips = [];
          
          for (const animName of animationNames) {
            try {
              const clip = await loadAnimationClip(modelName, animName, gltfObj);
              if (clip) {
                loadedClips.push(clip);
                console.log(`&#9989; Loaded animation: ${animName} for ${modelName}`);
              }
            } catch (error) {
              console.warn(`&#9888;&#65039; Failed to load animation ${animName} for ${modelName}:`, error);
            }
          }

          if (loadedClips.length === 0) {
            console.warn(`&#9888;&#65039; No animations loaded for ${modelName}`);
            return;
          }

          // Create clock and mixer for this model
          clocks[modelId] = new AFRAME.THREE.Clock();
          mixers[modelId] = new AFRAME.THREE.AnimationMixer(gltfObj);
          mixerActiveStates[modelId] = false;
          animationStates[modelId].clips = loadedClips;

          // Start with the first animation
          startAnimationSequence(modelId);
          
          // Start the animation update loop for this model
          function animateMixer() {
            rafIds[modelId] = requestAnimationFrame(animateMixer);
            if (!mixers[modelId] || !clocks[modelId]) return;
            const delta = clocks[modelId].getDelta();
            if (mixerActiveStates[modelId]) {
              mixers[modelId].update(delta);
              
              // Check if we should transition to next animation
              const state = animationStates[modelId];
              if (state.currentAction && !state.isTransitioning) {
                const currentTime = state.currentAction.time;
                const clipDuration = state.currentAction.getClip().duration;
                
                // Start transition before current animation ends
                if (currentTime >= clipDuration - state.transitionDuration - 0.1) {
                  startNextAnimation(modelId);
                }
              }
            }
          }

          // Start loop
          if (!rafIds[modelId]) animateMixer();
        }

        async function loadAnimationClip(modelName, animName, gltfObj) {
          return new Promise((resolve, reject) => {
            const animationPath = `AR/animations/${animName}.json`;
            
            console.log(`&#128193; Loading animation from: ${animationPath}`);
            
            fetch(animationPath)
              .then(response => {
                if (!response.ok) {
                  throw new Error(`Failed to load ${animName}.json`);
                }
                return response.json();
              })
              .then(animationData => {
                // Filter out problematic tracks
                const tracks = animationData.tracks.map(trackData => {
                  // Remove ALL scale tracks
                  if (trackData.name.includes('.scale')) {
                    return null;
                  }
                  
                  // Remove root bone rotations that cause flipping
                  if (trackData.name.includes('.quaternion')) {
                    const boneName = trackData.name.split('.')[0];
                    if (boneName.includes('Char_01') || boneName === 'Bone') {
                      return null;
                    }
                  }
                  
                  return new AFRAME.THREE.KeyframeTrack(
                    trackData.name,
                    new Float32Array(trackData.times),
                    new Float32Array(trackData.values)
                  );
                }).filter(track => track !== null);

                const clip = new AFRAME.THREE.AnimationClip(
                  animName,
                  animationData.duration,
                  tracks
                );
                
                resolve(clip);
              })
              .catch(error => {
                reject(error);
              });
          });
        }

        function startAnimationSequence(modelId) {
          const state = animationStates[modelId];
          if (!mixers[modelId] || state.clips.length === 0) return;
          
          state.currentClipIndex = 0;
          playClip(modelId, state.currentClipIndex);
        }

        function playClip(modelId, clipIndex) {
          const state = animationStates[modelId];
          if (!mixers[modelId] || !state.clips[clipIndex]) return;
          
          // Stop any current action immediately
          if (state.currentAction) {
            state.currentAction.stop();
          }
          
          // Play new clip
          state.currentClipIndex = clipIndex;
          state.currentAction = mixers[modelId].clipAction(state.clips[clipIndex]);
          state.currentAction.reset();
          state.currentAction.setLoop(AFRAME.THREE.LoopOnce, 1);
          state.currentAction.clampWhenFinished = true;
          state.currentAction.play();
          
          state.isTransitioning = false;
        }

        function startNextAnimation(modelId) {
          const state = animationStates[modelId];
          if (state.isTransitioning || !mixers[modelId]) return;
          
          state.isTransitioning = true;
          const nextClipIndex = (state.currentClipIndex + 1) % state.clips.length;
          
          // Prepare the next action
          state.nextAction = mixers[modelId].clipAction(state.clips[nextClipIndex]);
          state.nextAction.reset();
          state.nextAction.setLoop(AFRAME.THREE.LoopOnce, 1);
          state.nextAction.clampWhenFinished = true;
          
          // Use a much shorter, less exaggerated crossfade
          const quickTransitionDuration = 0.3;
          
          // Crossfade from current to next with minimal blending
          state.currentAction.crossFadeTo(state.nextAction, quickTransitionDuration, false);
          state.nextAction.play();
          
          // Update current references
          state.currentAction = state.nextAction;
          state.currentClipIndex = nextClipIndex;
          state.nextAction = null;
          
          // Reset transitioning flag after crossfade completes
          setTimeout(() => {
            state.isTransitioning = false;
          }, quickTransitionDuration * 1000);
        }

        // Sound control functions for individual markers
        function playMarkerSound(soundId) {
          const soundEl = document.querySelector(`#${soundId}`);
          if (soundEl) {
            const soundComponent = soundEl.components.sound;
            if (soundComponent) {
              if (soundWasBrieflyLost[soundId]) {
                soundComponent.playSound();
                soundWasBrieflyLost[soundId] = false;
              } else {
                soundComponent.stopSound();
                soundComponent.playSound();
              }
            }
          }
        }

        function stopMarkerSound(soundId) {
          const soundEl = document.querySelector(`#${soundId}`);
          if (soundEl) {
            const soundComponent = soundEl.components.sound;
            if (soundComponent) {
              soundComponent.stopSound();
            }
          }
        }

        // Set up orientation change listeners
        window.addEventListener('resize', detectOrientation);
        window.addEventListener('orientationchange', detectOrientation);
        setInterval(detectOrientation, 1000);

        // Clean up on unload
        window.addEventListener("beforeunload", () => {
          Object.values(rafIds).forEach(rafId => {
            if (rafId) cancelAnimationFrame(rafId);
          });
          Object.values(soundTimeouts).forEach(timeout => {
            if (timeout) clearTimeout(timeout);
          });
        });

      })();
    </script>
  </body>
</html>